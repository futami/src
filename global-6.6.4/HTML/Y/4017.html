<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>list</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/185.html#L17357'>list</a>             17357 libdb/sqlite3.c     } list;</span>
<span class='curline'><a href='../S/185.html#L17415'>list</a>             17415 libdb/sqlite3.c   u32 next = mem3.aPool[i].u.list.next;</span>
<span class='curline'><a href='../S/185.html#L17416'>list</a>             17416 libdb/sqlite3.c   u32 prev = mem3.aPool[i].u.list.prev;</span>
<span class='curline'><a href='../S/185.html#L17421'>list</a>             17421 libdb/sqlite3.c     mem3.aPool[prev].u.list.next = next;</span>
<span class='curline'><a href='../S/185.html#L17424'>list</a>             17424 libdb/sqlite3.c     mem3.aPool[next].u.list.prev = prev;</span>
<span class='curline'><a href='../S/185.html#L17426'>list</a>             17426 libdb/sqlite3.c   mem3.aPool[i].u.list.next = 0;</span>
<span class='curline'><a href='../S/185.html#L17427'>list</a>             17427 libdb/sqlite3.c   mem3.aPool[i].u.list.prev = 0;</span>
<span class='curline'><a href='../S/185.html#L17456'>list</a>             17456 libdb/sqlite3.c   mem3.aPool[i].u.list.next = *pRoot;</span>
<span class='curline'><a href='../S/185.html#L17457'>list</a>             17457 libdb/sqlite3.c   mem3.aPool[i].u.list.prev = 0;</span>
<span class='curline'><a href='../S/185.html#L17459'>list</a>             17459 libdb/sqlite3.c     mem3.aPool[*pRoot].u.list.prev = i;</span>
<span class='curline'><a href='../S/185.html#L17587'>list</a>             17587 libdb/sqlite3.c     iNext = mem3.aPool[i].u.list.next;</span>
<span class='curline'><a href='../S/185.html#L17595'>list</a>             17595 libdb/sqlite3.c         iNext = mem3.aPool[prev].u.list.next;</span>
<span class='curline'><a href='../S/185.html#L17648'>list</a>             17648 libdb/sqlite3.c     for(i=mem3.aiHash[hash]; i&gt;0; i=mem3.aPool[i].u.list.next){</span>
<span class='curline'><a href='../S/185.html#L17900'>list</a>             17900 libdb/sqlite3.c     for(j = mem3.aiSmall[i]; j&gt;0; j=mem3.aPool[j].u.list.next){</span>
<span class='curline'><a href='../S/185.html#L17909'>list</a>             17909 libdb/sqlite3.c     for(j = mem3.aiHash[i]; j&gt;0; j=mem3.aPool[j].u.list.next){</span>
<span class='curline'><a href='../S/185.html#L76233'>list</a>             76233 libdb/sqlite3.c   SorterList list;                /* List for thread to write to a PMA */</span>
<span class='curline'><a href='../S/185.html#L76258'>list</a>             76258 libdb/sqlite3.c   SorterList list;                /* List of in-memory records */</span>
<span class='curline'><a href='../S/185.html#L76800'>list</a>             76800 libdb/sqlite3.c         pSorter-&gt;list.aMemory = (u8*)sqlite3Malloc(pgsz);</span>
<span class='curline'><a href='../S/185.html#L76801'>list</a>             76801 libdb/sqlite3.c         if( !pSorter-&gt;list.aMemory ) rc = SQLITE_NOMEM;</span>
<span class='curline'><a href='../S/185.html#L76832'>list</a>             76832 libdb/sqlite3.c   if( pTask-&gt;list.aMemory ){</span>
<span class='curline'><a href='../S/185.html#L76833'>list</a>             76833 libdb/sqlite3.c     sqlite3_free(pTask-&gt;list.aMemory);</span>
<span class='curline'><a href='../S/185.html#L76834'>list</a>             76834 libdb/sqlite3.c     pTask-&gt;list.aMemory = 0;</span>
<span class='curline'><a href='../S/185.html#L76838'>list</a>             76838 libdb/sqlite3.c     assert( pTask-&gt;list.aMemory==0 );</span>
<span class='curline'><a href='../S/185.html#L76839'>list</a>             76839 libdb/sqlite3.c     vdbeSorterRecordFree(0, pTask-&gt;list.pList);</span>
<span class='curline'><a href='../S/185.html#L76841'>list</a>             76841 libdb/sqlite3.c   pTask-&gt;list.pList = 0;</span>
<span class='curline'><a href='../S/185.html#L77032'>list</a>             77032 libdb/sqlite3.c   if( pSorter-&gt;list.aMemory==0 ){</span>
<span class='curline'><a href='../S/185.html#L77033'>list</a>             77033 libdb/sqlite3.c     vdbeSorterRecordFree(0, pSorter-&gt;list.pList);</span>
<span class='curline'><a href='../S/185.html#L77035'>list</a>             77035 libdb/sqlite3.c   pSorter-&gt;list.pList = 0;</span>
<span class='curline'><a href='../S/185.html#L77036'>list</a>             77036 libdb/sqlite3.c   pSorter-&gt;list.szPMA = 0;</span>
<span class='curline'><a href='../S/185.html#L77051'>list</a>             77051 libdb/sqlite3.c     sqlite3_free(pSorter-&gt;list.aMemory);</span>
<span class='curline'><a href='../S/185.html#L77454'>list</a>             77454 libdb/sqlite3.c   rc = vdbeSorterListToPMA(pTask, &amp;pTask-&gt;list);</span>
<span class='curline'><a href='../S/185.html#L77467'>list</a>             77467 libdb/sqlite3.c   return vdbeSorterListToPMA(&amp;pSorter-&gt;aTask[0], &amp;pSorter-&gt;list);</span>
<span class='curline'><a href='../S/185.html#L77498'>list</a>             77498 libdb/sqlite3.c       rc = vdbeSorterListToPMA(&amp;pSorter-&gt;aTask[nWorker], &amp;pSorter-&gt;list);</span>
<span class='curline'><a href='../S/185.html#L77501'>list</a>             77501 libdb/sqlite3.c       u8 *aMem = pTask-&gt;list.aMemory;</span>
<span class='curline'><a href='../S/185.html#L77505'>list</a>             77505 libdb/sqlite3.c       assert( pTask-&gt;list.pList==0 );</span>
<span class='curline'><a href='../S/185.html#L77506'>list</a>             77506 libdb/sqlite3.c       assert( pTask-&gt;list.aMemory==0 || pSorter-&gt;list.aMemory!=0 );</span>
<span class='curline'><a href='../S/185.html#L77509'>list</a>             77509 libdb/sqlite3.c       pTask-&gt;list = pSorter-&gt;list;</span>
<span class='curline'><a href='../S/185.html#L77510'>list</a>             77510 libdb/sqlite3.c       pSorter-&gt;list.pList = 0;</span>
<span class='curline'><a href='../S/185.html#L77511'>list</a>             77511 libdb/sqlite3.c       pSorter-&gt;list.szPMA = 0;</span>
<span class='curline'><a href='../S/185.html#L77513'>list</a>             77513 libdb/sqlite3.c         pSorter-&gt;list.aMemory = aMem;</span>
<span class='curline'><a href='../S/185.html#L77515'>list</a>             77515 libdb/sqlite3.c       }else if( pSorter-&gt;list.aMemory ){</span>
<span class='curline'><a href='../S/185.html#L77516'>list</a>             77516 libdb/sqlite3.c         pSorter-&gt;list.aMemory = sqlite3Malloc(pSorter-&gt;nMemory);</span>
<span class='curline'><a href='../S/185.html#L77517'>list</a>             77517 libdb/sqlite3.c         if( !pSorter-&gt;list.aMemory ) return SQLITE_NOMEM;</span>
<span class='curline'><a href='../S/185.html#L77564'>list</a>             77564 libdb/sqlite3.c     if( pSorter-&gt;list.aMemory ){</span>
<span class='curline'><a href='../S/185.html#L77568'>list</a>             77568 libdb/sqlite3.c           (pSorter-&gt;list.szPMA &gt; pSorter-&gt;mxPmaSize)</span>
<span class='curline'><a href='../S/185.html#L77569'>list</a>             77569 libdb/sqlite3.c        || (pSorter-&gt;list.szPMA &gt; pSorter-&gt;mnPmaSize &amp;&amp; sqlite3HeapNearlyFull())</span>
<span class='curline'><a href='../S/185.html#L77574'>list</a>             77574 libdb/sqlite3.c       pSorter-&gt;list.szPMA = 0;</span>
<span class='curline'><a href='../S/185.html#L77576'>list</a>             77576 libdb/sqlite3.c       assert( rc!=SQLITE_OK || pSorter-&gt;list.pList==0 );</span>
<span class='curline'><a href='../S/185.html#L77580'>list</a>             77580 libdb/sqlite3.c   pSorter-&gt;list.szPMA += nPMA;</span>
<span class='curline'><a href='../S/185.html#L77585'>list</a>             77585 libdb/sqlite3.c   if( pSorter-&gt;list.aMemory ){</span>
<span class='curline'><a href='../S/185.html#L77595'>list</a>             77595 libdb/sqlite3.c       aNew = sqlite3Realloc(pSorter-&gt;list.aMemory, nNew);</span>
<span class='curline'><a href='../S/185.html#L77597'>list</a>             77597 libdb/sqlite3.c       pSorter-&gt;list.pList = (SorterRecord*)(</span>
<span class='curline'><a href='../S/185.html#L77598'>list</a>             77598 libdb/sqlite3.c           aNew + ((u8*)pSorter-&gt;list.pList - pSorter-&gt;list.aMemory)</span>
<span class='curline'><a href='../S/185.html#L77600'>list</a>             77600 libdb/sqlite3.c       pSorter-&gt;list.aMemory = aNew;</span>
<span class='curline'><a href='../S/185.html#L77604'>list</a>             77604 libdb/sqlite3.c     pNew = (SorterRecord*)&amp;pSorter-&gt;list.aMemory[pSorter-&gt;iMemory];</span>
<span class='curline'><a href='../S/185.html#L77606'>list</a>             77606 libdb/sqlite3.c     pNew-&gt;u.iNext = (int)((u8*)(pSorter-&gt;list.pList) - pSorter-&gt;list.aMemory);</span>
<span class='curline'><a href='../S/185.html#L77612'>list</a>             77612 libdb/sqlite3.c     pNew-&gt;u.pNext = pSorter-&gt;list.pList;</span>
<span class='curline'><a href='../S/185.html#L77617'>list</a>             77617 libdb/sqlite3.c   pSorter-&gt;list.pList = pNew;</span>
<span class='curline'><a href='../S/185.html#L78303'>list</a>             78303 libdb/sqlite3.c     if( pSorter-&gt;list.pList ){</span>
<span class='curline'><a href='../S/185.html#L78305'>list</a>             78305 libdb/sqlite3.c       rc = vdbeSorterSort(&amp;pSorter-&gt;aTask[0], &amp;pSorter-&gt;list);</span>
<span class='curline'><a href='../S/185.html#L78316'>list</a>             78316 libdb/sqlite3.c   assert( pSorter-&gt;list.pList );</span>
<span class='curline'><a href='../S/185.html#L78359'>list</a>             78359 libdb/sqlite3.c     SorterRecord *pFree = pSorter-&gt;list.pList;</span>
<span class='curline'><a href='../S/185.html#L78360'>list</a>             78360 libdb/sqlite3.c     pSorter-&gt;list.pList = pFree-&gt;u.pNext;</span>
<span class='curline'><a href='../S/185.html#L78362'>list</a>             78362 libdb/sqlite3.c     if( pSorter-&gt;list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);</span>
<span class='curline'><a href='../S/185.html#L78363'>list</a>             78363 libdb/sqlite3.c     *pbEof = !pSorter-&gt;list.pList;</span>
<span class='curline'><a href='../S/185.html#L78391'>list</a>             78391 libdb/sqlite3.c     *pnKey = pSorter-&gt;list.pList-&gt;nVal;</span>
<span class='curline'><a href='../S/185.html#L78392'>list</a>             78392 libdb/sqlite3.c     pKey = SRVAL(pSorter-&gt;list.pList);</span>
<span class='curline'><a href='../S/218.html#L343'>list</a>              343 libltdl/loaders/preopen.c   symlist_chain *list;</span>
<span class='curline'><a href='../S/218.html#L348'>list</a>              348 libltdl/loaders/preopen.c   for (list = preloaded_symlists; list; list = list-&gt;next)</span>
<span class='curline'><a href='../S/218.html#L351'>list</a>              351 libltdl/loaders/preopen.c       if ((originator &amp;&amp; STREQ (list-&gt;symlist-&gt;name, originator))</span>
<span class='curline'><a href='../S/218.html#L352'>list</a>              352 libltdl/loaders/preopen.c           || (!originator &amp;&amp; STREQ (list-&gt;symlist-&gt;name, "@PROGRAM@")))</span>
<span class='curline'><a href='../S/218.html#L361'>list</a>              361 libltdl/loaders/preopen.c 	  while ((symbol = &amp;list-&gt;symlist[++idx])-&gt;name != 0)</span>
<span class='curline'><a href='../S/310.html#L96'>list</a>               96 libutil/langmap.c trim_suffix_list(STRBUF *list, STRHASH *hash) {</span>
<span class='curline'><a href='../S/310.html#L101'>list</a>              101 libutil/langmap.c 	strbuf_puts(sb, strbuf_value(list));</span>
<span class='curline'><a href='../S/310.html#L102'>list</a>              102 libutil/langmap.c 	strbuf_reset(list);</span>
<span class='curline'><a href='../S/310.html#L132'>list</a>              132 libutil/langmap.c 			strbuf_puts(list, strbuf_value(suffix));</span>
<span class='curline'><a href='../S/310.html#L154'>list</a>              154 libutil/langmap.c 		char *list;	/* suffixes: .cpp.c++ */</span>
<span class='curline'><a href='../S/310.html#L159'>list</a>              159 libutil/langmap.c 	STRBUF *list = strbuf_open(0);</span>
<span class='curline'><a href='../S/310.html#L168'>list</a>              168 libutil/langmap.c 		strbuf_reset(list);</span>
<span class='curline'><a href='../S/310.html#L171'>list</a>              171 libutil/langmap.c 		strbuf_puts(list, strmake(p, ","));</span>
<span class='curline'><a href='../S/310.html#L172'>list</a>              172 libutil/langmap.c 		p += strbuf_getlen(list);</span>
<span class='curline'><a href='../S/310.html#L182'>list</a>              182 libutil/langmap.c 		trim_suffix_list(list, hash);</span>
<span class='curline'><a href='../S/310.html#L183'>list</a>              183 libutil/langmap.c 		if (strbuf_getlen(list) == 0)</span>
<span class='curline'><a href='../S/310.html#L200'>list</a>              200 libutil/langmap.c 			ent-&gt;list = check_strdup(strbuf_value(list));</span>
<span class='curline'><a href='../S/310.html#L203'>list</a>              203 libutil/langmap.c 			ent-&gt;list = check_realloc(ent-&gt;list,</span>
<span class='curline'><a href='../S/310.html#L204'>list</a>              204 libutil/langmap.c 				strlen(ent-&gt;list) + strbuf_getlen(list) + 1);</span>
<span class='curline'><a href='../S/310.html#L205'>list</a>              205 libutil/langmap.c 			strcat(ent-&gt;list, strbuf_value(list));</span>
<span class='curline'><a href='../S/310.html#L214'>list</a>              214 libutil/langmap.c 		strbuf_puts(sb, ent-&gt;list);</span>
<span class='curline'><a href='../S/310.html#L216'>list</a>              216 libutil/langmap.c 		free(ent-&gt;list);</span>
<span class='curline'><a href='../S/310.html#L219'>list</a>              219 libutil/langmap.c 	strbuf_close(list);</span>
<span class='curline'><a href='../S/310.html#L235'>list</a>              235 libutil/langmap.c 	const char *lang, *list, *tail;</span>
<span class='curline'><a href='../S/310.html#L249'>list</a>              249 libutil/langmap.c 		list = lang + strlen(lang) + 1;</span>
<span class='curline'><a href='../S/310.html#L250'>list</a>              250 libutil/langmap.c 		if (match_suffix_list(suffix, NULL, list))</span>
<span class='curline'><a href='../S/310.html#L252'>list</a>              252 libutil/langmap.c 		lang = list + strlen(list) + 1;</span>
<span class='curline'><a href='../S/310.html#L262'>list</a>              262 libutil/langmap.c 	const char *lang, *list, *tail;</span>
<span class='curline'><a href='../S/310.html#L280'>list</a>              280 libutil/langmap.c 		list = lang + strlen(lang) + 1;</span>
<span class='curline'><a href='../S/310.html#L281'>list</a>              281 libutil/langmap.c 		if (match_suffix_list(suffix, basename, list))</span>
<span class='curline'><a href='../S/310.html#L283'>list</a>              283 libutil/langmap.c 		lang = list + strlen(list) + 1;</span>
<span class='curline'><a href='../S/310.html#L298'>list</a>              298 libutil/langmap.c match_suffix_list(const char *suffix, const char *basename, const char *list)</span>
<span class='curline'><a href='../S/310.html#L307'>list</a>              307 libutil/langmap.c 	while (*list) {</span>
<span class='curline'><a href='../S/310.html#L308'>list</a>              308 libutil/langmap.c 		if (*list == '.') {</span>
<span class='curline'><a href='../S/310.html#L309'>list</a>              309 libutil/langmap.c 			p = strmake(++list, ".(");</span>
<span class='curline'><a href='../S/310.html#L319'>list</a>              319 libutil/langmap.c 			list += strlen(p);</span>
<span class='curline'><a href='../S/310.html#L320'>list</a>              320 libutil/langmap.c 		} else if (*list == '(') {</span>
<span class='curline'><a href='../S/310.html#L321'>list</a>              321 libutil/langmap.c 			p = strmake(++list, ")");</span>
<span class='curline'><a href='../S/310.html#L328'>list</a>              328 libutil/langmap.c 			list += strlen(p) + 1;</span>
<span class='curline'><a href='../S/336.html#L93'>list</a>               93 libutil/split.c split(const char *line, int npart, SPLIT *list)		/* virtually const */</span>
<span class='curline'><a href='../S/336.html#L96'>list</a>               96 libutil/split.c 	struct part *part = &amp;list-&gt;part[0];</span>
<span class='curline'><a href='../S/336.html#L123'>list</a>              123 libutil/split.c 	while (part-- &gt; &amp;list-&gt;part[0]) {</span>
<span class='curline'><a href='../S/336.html#L127'>list</a>              127 libutil/split.c 	return list-&gt;npart = count;</span>
<span class='curline'><a href='../S/336.html#L135'>list</a>              135 libutil/split.c recover(SPLIT *list)</span>
<span class='curline'><a href='../S/336.html#L138'>list</a>              138 libutil/split.c 	for (i = 0; i &lt; list-&gt;npart; i++) {</span>
<span class='curline'><a href='../S/336.html#L139'>list</a>              139 libutil/split.c 		if ((c = list-&gt;part[i].savec) != '\0')</span>
<span class='curline'><a href='../S/336.html#L140'>list</a>              140 libutil/split.c 			*(list-&gt;part[i].end) = c;</span>
<span class='curline'><a href='../S/336.html#L147'>list</a>              147 libutil/split.c split_dump(SPLIT *list)</span>
<span class='curline'><a href='../S/336.html#L152'>list</a>              152 libutil/split.c 	fprintf(stderr, "npart: %d\n", list-&gt;npart);</span>
<span class='curline'><a href='../S/336.html#L154'>list</a>              154 libutil/split.c 	for (i = 0; i &lt; list-&gt;npart; i++) {</span>
<span class='curline'><a href='../S/336.html#L155'>list</a>              155 libutil/split.c 		part = &amp;list-&gt;part[i];</span>
</pre>
</body>
</html>
