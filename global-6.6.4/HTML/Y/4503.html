<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>nKey</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/185.html#L4794'>nKey</a>             4794 libdb/sqlite3.c   const void *pKey, int nKey     /* The key */</span>
<span class='curline'><a href='../S/185.html#L4799'>nKey</a>             4799 libdb/sqlite3.c   const void *pKey, int nKey     /* The key */</span>
<span class='curline'><a href='../S/185.html#L4812'>nKey</a>             4812 libdb/sqlite3.c   const void *pKey, int nKey     /* The new key */</span>
<span class='curline'><a href='../S/185.html#L4817'>nKey</a>             4817 libdb/sqlite3.c   const void *pKey, int nKey     /* The new key */</span>
<span class='curline'><a href='../S/185.html#L9105'>nKey</a>             9105 libdb/sqlite3.c SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const void *pKey, i64 nKey,</span>
<span class='curline'><a href='../S/185.html#L51686'>nKey</a>             51686 libdb/sqlite3.c   i64 nKey;      /* The key for INTKEY tables, or nPayload otherwise */</span>
<span class='curline'><a href='../S/185.html#L51726'>nKey</a>             51726 libdb/sqlite3.c   i64 nKey;                 /* Size of pKey, or last integer key */</span>
<span class='curline'><a href='../S/185.html#L52675'>nKey</a>             52675 libdb/sqlite3.c      &amp;&amp; (isClearTable || p-&gt;info.nKey==iRow)</span>
<span class='curline'><a href='../S/185.html#L52785'>nKey</a>             52785 libdb/sqlite3.c   rc = sqlite3BtreeKeySize(pCur, &amp;pCur-&gt;nKey);</span>
<span class='curline'><a href='../S/185.html#L52795'>nKey</a>             52795 libdb/sqlite3.c     void *pKey = sqlite3Malloc( pCur-&gt;nKey );</span>
<span class='curline'><a href='../S/185.html#L52797'>nKey</a>             52797 libdb/sqlite3.c       rc = sqlite3BtreeKey(pCur, 0, (int)pCur-&gt;nKey, pKey);</span>
<span class='curline'><a href='../S/185.html#L52888'>nKey</a>             52888 libdb/sqlite3.c   i64 nKey,           /* Integer key for tables.  Size of pKey for indices */</span>
<span class='curline'><a href='../S/185.html#L52898'>nKey</a>             52898 libdb/sqlite3.c     assert( nKey==(i64)(int)nKey );</span>
<span class='curline'><a href='../S/185.html#L52903'>nKey</a>             52903 libdb/sqlite3.c     sqlite3VdbeRecordUnpack(pCur-&gt;pKeyInfo, (int)nKey, pKey, pIdxKey);</span>
<span class='curline'><a href='../S/185.html#L52911'>nKey</a>             52911 libdb/sqlite3.c   rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);</span>
<span class='curline'><a href='../S/185.html#L52933'>nKey</a>             52933 libdb/sqlite3.c   rc = btreeMoveto(pCur, pCur-&gt;pKey, pCur-&gt;nKey, 0, &amp;pCur-&gt;skipNext);</span>
<span class='curline'><a href='../S/185.html#L53171'>nKey</a>             53171 libdb/sqlite3.c     pIter += getVarint(pIter, (u64*)&amp;pInfo-&gt;nKey);</span>
<span class='curline'><a href='../S/185.html#L53174'>nKey</a>             53174 libdb/sqlite3.c     pInfo-&gt;nSize = 4 + getVarint(&amp;pCell[4], (u64*)&amp;pInfo-&gt;nKey);</span>
<span class='curline'><a href='../S/185.html#L53183'>nKey</a>             53183 libdb/sqlite3.c     pInfo-&gt;nKey = nPayload;</span>
<span class='curline'><a href='../S/185.html#L56044'>nKey</a>             56044 libdb/sqlite3.c     *pSize = pCur-&gt;info.nKey;</span>
<span class='curline'><a href='../S/185.html#L56848'>nKey</a>             56848 libdb/sqlite3.c     if( pCur-&gt;info.nKey==intKey ){</span>
<span class='curline'><a href='../S/185.html#L56852'>nKey</a>             56852 libdb/sqlite3.c     if( (pCur-&gt;curFlags &amp; BTCF_AtLast)!=0 &amp;&amp; pCur-&gt;info.nKey&lt;intKey ){</span>
<span class='curline'><a href='../S/185.html#L56920'>nKey</a>             56920 libdb/sqlite3.c           pCur-&gt;info.nKey = nCellKey;</span>
<span class='curline'><a href='../S/185.html#L56969'>nKey</a>             56969 libdb/sqlite3.c           nCell = (int)pCur-&gt;info.nKey;</span>
<span class='curline'><a href='../S/185.html#L57811'>nKey</a>             57811 libdb/sqlite3.c   const void *pKey, i64 nKey,    /* The key */</span>
<span class='curline'><a href='../S/185.html#L57844'>nKey</a>             57844 libdb/sqlite3.c   nHeader += putVarint(&amp;pCell[nHeader], *(u64*)&amp;nKey);</span>
<span class='curline'><a href='../S/185.html#L57852'>nKey</a>             57852 libdb/sqlite3.c     if( NEVER(nKey&gt;0x7fffffff || pKey==0) ){</span>
<span class='curline'><a href='../S/185.html#L57855'>nKey</a>             57855 libdb/sqlite3.c     nPayload = (int)nKey;</span>
<span class='curline'><a href='../S/185.html#L57857'>nKey</a>             57857 libdb/sqlite3.c     nSrc = (int)nKey;</span>
<span class='curline'><a href='../S/185.html#L57896'>nKey</a>             57896 libdb/sqlite3.c     assert( info.nKey==nKey );</span>
<span class='curline'><a href='../S/185.html#L58875'>nKey</a>             58875 libdb/sqlite3.c         sz = 4 + putVarint(&amp;pCell[4], info.nKey);</span>
<span class='curline'><a href='../S/185.html#L59278'>nKey</a>             59278 libdb/sqlite3.c   const void *pKey, i64 nKey,    /* The key of the new record */</span>
<span class='curline'><a href='../S/185.html#L59329'>nKey</a>             59329 libdb/sqlite3.c     invalidateIncrblobCursors(p, nKey, 0);</span>
<span class='curline'><a href='../S/185.html#L59334'>nKey</a>             59334 libdb/sqlite3.c     if( (pCur-&gt;curFlags&amp;BTCF_ValidNKey)!=0 &amp;&amp; nKey&gt;0</span>
<span class='curline'><a href='../S/185.html#L59335'>nKey</a>             59335 libdb/sqlite3.c       &amp;&amp; pCur-&gt;info.nKey==nKey-1 ){</span>
<span class='curline'><a href='../S/185.html#L59341'>nKey</a>             59341 libdb/sqlite3.c     rc = btreeMoveto(pCur, pKey, nKey, appendBias, &amp;loc);</span>
<span class='curline'><a href='../S/185.html#L59347'>nKey</a>             59347 libdb/sqlite3.c   assert( pPage-&gt;intKey || nKey&gt;=0 );</span>
<span class='curline'><a href='../S/185.html#L59351'>nKey</a>             59351 libdb/sqlite3.c           pCur-&gt;pgnoRoot, nKey, nData, pPage-&gt;pgno,</span>
<span class='curline'><a href='../S/185.html#L59356'>nKey</a>             59356 libdb/sqlite3.c   rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, &amp;szNew);</span>
<span class='curline'><a href='../S/185.html#L59478'>nKey</a>             59478 libdb/sqlite3.c     invalidateIncrblobCursors(p, pCur-&gt;info.nKey, 0);</span>
<span class='curline'><a href='../S/185.html#L60329'>nKey</a>             60329 libdb/sqlite3.c         nMinKey = nMaxKey = info.nKey;</span>
<span class='curline'><a href='../S/185.html#L60330'>nKey</a>             60330 libdb/sqlite3.c       }else if( info.nKey &lt;= nMaxKey ){</span>
<span class='curline'><a href='../S/185.html#L60332'>nKey</a>             60332 libdb/sqlite3.c            "Rowid %lld out of order (previous was %lld)", info.nKey, nMaxKey);</span>
<span class='curline'><a href='../S/185.html#L60334'>nKey</a>             60334 libdb/sqlite3.c       nMaxKey = info.nKey;</span>
<span class='curline'><a href='../S/185.html#L66342'>nKey</a>             66342 libdb/sqlite3.c   int nKey,              /* Size of the binary record */</span>
<span class='curline'><a href='../S/185.html#L66358'>nKey</a>             66358 libdb/sqlite3.c   while( idx&lt;szHdr &amp;&amp; d&lt;=nKey ){</span>
<span class='curline'><a href='../S/185.html#L73679'>nKey</a>             73679 libdb/sqlite3.c   int nKey;</span>
<span class='curline'><a href='../S/185.html#L73697'>nKey</a>             73697 libdb/sqlite3.c       nKey = pIn2-&gt;n;</span>
<span class='curline'><a href='../S/185.html#L73699'>nKey</a>             73699 libdb/sqlite3.c       rc = sqlite3BtreeInsert(pCrsr, zKey, nKey, "", 0, 0, pOp-&gt;p3, </span>
<span class='curline'><a href='../S/185.html#L76281'>nKey</a>             76281 libdb/sqlite3.c   int nKey;                   /* Number of bytes in key */</span>
<span class='curline'><a href='../S/185.html#L76637'>nKey</a>             76637 libdb/sqlite3.c     pReadr-&gt;nKey = (int)nRec;</span>
<span class='curline'><a href='../S/185.html#L77411'>nKey</a>             77411 libdb/sqlite3.c             pReadr1-&gt;aKey, pReadr1-&gt;nKey, pKey2, pReadr2-&gt;nKey</span>
<span class='curline'><a href='../S/185.html#L77643'>nKey</a>             77643 libdb/sqlite3.c     int nKey = pReader-&gt;nKey;</span>
<span class='curline'><a href='../S/185.html#L77649'>nKey</a>             77649 libdb/sqlite3.c     if( (iEof + nKey + sqlite3VarintLen(nKey))&gt;(iStart + pIncr-&gt;mxSz) ) break;</span>
<span class='curline'><a href='../S/185.html#L77652'>nKey</a>             77652 libdb/sqlite3.c     vdbePmaWriteVarint(&amp;writer, nKey);</span>
<span class='curline'><a href='../S/185.html#L77653'>nKey</a>             77653 libdb/sqlite3.c     vdbePmaWriteBlob(&amp;writer, pReader-&gt;aKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L77810'>nKey</a>             77810 libdb/sqlite3.c         pMerger-&gt;pTask, p1-&gt;aKey, p1-&gt;nKey, p2-&gt;aKey, p2-&gt;nKey</span>
<span class='curline'><a href='../S/185.html#L78388'>nKey</a>             78388 libdb/sqlite3.c     *pnKey = pReader-&gt;nKey;</span>
<span class='curline'><a href='../S/185.html#L78402'>nKey</a>             78402 libdb/sqlite3.c   void *pKey; int nKey;           /* Sorter key to copy into pOut */</span>
<span class='curline'><a href='../S/185.html#L78404'>nKey</a>             78404 libdb/sqlite3.c   pKey = vdbeSorterRowkey(pSorter, &amp;nKey);</span>
<span class='curline'><a href='../S/185.html#L78405'>nKey</a>             78405 libdb/sqlite3.c   if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){</span>
<span class='curline'><a href='../S/185.html#L78408'>nKey</a>             78408 libdb/sqlite3.c   pOut-&gt;n = nKey;</span>
<span class='curline'><a href='../S/185.html#L78410'>nKey</a>             78410 libdb/sqlite3.c   memcpy(pOut-&gt;z, pKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L78441'>nKey</a>             78441 libdb/sqlite3.c   void *pKey; int nKey;           /* Sorter key to compare pVal with */</span>
<span class='curline'><a href='../S/185.html#L78452'>nKey</a>             78452 libdb/sqlite3.c   pKey = vdbeSorterRowkey(pSorter, &amp;nKey);</span>
<span class='curline'><a href='../S/185.html#L78453'>nKey</a>             78453 libdb/sqlite3.c   sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2);</span>
<span class='curline'><a href='../S/185.html#L87834'>nKey</a>             87834 libdb/sqlite3.c     int nKey;</span>
<span class='curline'><a href='../S/185.html#L87846'>nKey</a>             87846 libdb/sqlite3.c         nKey = sqlite3_value_bytes(argv[2]);</span>
<span class='curline'><a href='../S/185.html#L87848'>nKey</a>             87848 libdb/sqlite3.c         rc = sqlite3CodecAttach(db, db-&gt;nDb-1, zKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L87853'>nKey</a>             87853 libdb/sqlite3.c         sqlite3CodecGetKey(db, 0, (void**)&amp;zKey, &amp;nKey);</span>
<span class='curline'><a href='../S/185.html#L87854'>nKey</a>             87854 libdb/sqlite3.c         if( nKey&gt;0 || sqlite3BtreeGetReserve(db-&gt;aDb[0].pBt)&gt;0 ){</span>
<span class='curline'><a href='../S/185.html#L87855'>nKey</a>             87855 libdb/sqlite3.c           rc = sqlite3CodecAttach(db, db-&gt;nDb-1, zKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L92705'>nKey</a>             92705 libdb/sqlite3.c     int nKey = pIdx-&gt;nKeyCol;</span>
<span class='curline'><a href='../S/185.html#L92708'>nKey</a>             92708 libdb/sqlite3.c       pKey = sqlite3KeyInfoAlloc(pParse-&gt;db, nKey, nCol-nKey);</span>
<span class='curline'><a href='../S/185.html#L93525'>nKey</a>             93525 libdb/sqlite3.c   i16 nKey;              /* Number of memory cells in the row key */</span>
<span class='curline'><a href='../S/185.html#L93709'>nKey</a>             93709 libdb/sqlite3.c       nKey = nPk; /* OP_Found will use an unpacked key */</span>
<span class='curline'><a href='../S/185.html#L93724'>nKey</a>             93724 libdb/sqlite3.c       nKey = 0;   /* Zero tells OP_Found to use a composite key */</span>
<span class='curline'><a href='../S/185.html#L93730'>nKey</a>             93730 libdb/sqlite3.c       nKey = 1;  /* OP_Seek always uses a single rowid */</span>
<span class='curline'><a href='../S/185.html#L93761'>nKey</a>             93761 libdb/sqlite3.c       assert( nKey==nPk );  /* OP_Found will use an unpacked key */</span>
<span class='curline'><a href='../S/185.html#L93765'>nKey</a>             93765 libdb/sqlite3.c         sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L93771'>nKey</a>             93771 libdb/sqlite3.c       assert( nKey==0 );  /* OP_Found will use a composite key */</span>
<span class='curline'><a href='../S/185.html#L93775'>nKey</a>             93775 libdb/sqlite3.c       assert( nKey==1 );</span>
<span class='curline'><a href='../S/185.html#L93791'>nKey</a>             93791 libdb/sqlite3.c                                iKey, nKey, count, OE_Default, okOnePass);</span>
<span class='curline'><a href='../S/185.html#L104541'>nKey</a>             104541 libdb/sqlite3.c     int nKey;         /* Number of sorting key columns, including OP_Sequence */</span>
<span class='curline'><a href='../S/185.html#L104546'>nKey</a>             104546 libdb/sqlite3.c     nKey = nExpr - pSort-&gt;nOBSat + bSeq;</span>
<span class='curline'><a href='../S/185.html#L104556'>nKey</a>             104556 libdb/sqlite3.c     pOp-&gt;p2 = nKey + nData;</span>
<span class='curline'><a href='../S/185.html#L104930'>nKey</a>             104930 libdb/sqlite3.c       int nKey;</span>
<span class='curline'><a href='../S/185.html#L104936'>nKey</a>             104936 libdb/sqlite3.c       nKey = pSO-&gt;nExpr;</span>
<span class='curline'><a href='../S/185.html#L104938'>nKey</a>             104938 libdb/sqlite3.c       r2 = sqlite3GetTempRange(pParse, nKey+2);</span>
<span class='curline'><a href='../S/185.html#L104939'>nKey</a>             104939 libdb/sqlite3.c       r3 = r2+nKey+1;</span>
<span class='curline'><a href='../S/185.html#L104953'>nKey</a>             104953 libdb/sqlite3.c       for(i=0; i&lt;nKey; i++){</span>
<span class='curline'><a href='../S/185.html#L104958'>nKey</a>             104958 libdb/sqlite3.c       sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);</span>
<span class='curline'><a href='../S/185.html#L104959'>nKey</a>             104959 libdb/sqlite3.c       sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);</span>
<span class='curline'><a href='../S/185.html#L104963'>nKey</a>             104963 libdb/sqlite3.c       sqlite3ReleaseTempRange(pParse, r2, nKey+2);</span>
<span class='curline'><a href='../S/185.html#L105196'>nKey</a>             105196 libdb/sqlite3.c   int nKey;</span>
<span class='curline'><a href='../S/185.html#L105220'>nKey</a>             105220 libdb/sqlite3.c   nKey = pOrderBy-&gt;nExpr - pSort-&gt;nOBSat;</span>
<span class='curline'><a href='../S/185.html#L105227'>nKey</a>             105227 libdb/sqlite3.c     sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut, nKey+1+nSortData);</span>
<span class='curline'><a href='../S/185.html#L105241'>nKey</a>             105241 libdb/sqlite3.c     sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq+i, regRow+i);</span>
<span class='curline'><a href='../S/185.html#L110986'>nKey</a>             110986 libdb/sqlite3.c   int nKey = 0;          /* Number of elements in regKey for WITHOUT ROWID */</span>
<span class='curline'><a href='../S/185.html#L111243'>nKey</a>             111243 libdb/sqlite3.c       nKey = nPk;</span>
<span class='curline'><a href='../S/185.html#L111290'>nKey</a>             111290 libdb/sqlite3.c       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelBreak, regKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L111398'>nKey</a>             111398 libdb/sqlite3.c       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue,regKey,nKey);</span>
<span class='curline'><a href='../S/185.html#L111434'>nKey</a>             111434 libdb/sqlite3.c         j1 = sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, 0, regKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L111822'>nKey</a>             111822 libdb/sqlite3.c     int nKey;</span>
<span class='curline'><a href='../S/185.html#L111824'>nKey</a>             111824 libdb/sqlite3.c     sqlite3CodecGetKey(db, 0, (void**)&amp;zKey, &amp;nKey);</span>
<span class='curline'><a href='../S/185.html#L111825'>nKey</a>             111825 libdb/sqlite3.c     if( nKey ) db-&gt;nextPagesize = 0;</span>
<span class='curline'><a href='../S/185.html#L129261'>nKey</a>             129261 libdb/sqlite3.c   void *pKey; int nKey;      /* Key associated with this element */</span>
<span class='curline'><a href='../S/185.html#L129283'>nKey</a>             129283 libdb/sqlite3.c SQLITE_PRIVATE void *sqlite3Fts3HashInsert(Fts3Hash*, const void *pKey, int nKey, void *pData);</span>
<span class='curline'><a href='../S/185.html#L129284'>nKey</a>             129284 libdb/sqlite3.c SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash*, const void *pKey, int nKey);</span>
<span class='curline'><a href='../S/185.html#L129313'>nKey</a>             129313 libdb/sqlite3.c #define fts3HashKeysize(E) ((E)-&gt;nKey)</span>
<span class='curline'><a href='../S/185.html#L130737'>nKey</a>             130737 libdb/sqlite3.c     int nKey;</span>
<span class='curline'><a href='../S/185.html#L130750'>nKey</a>             130750 libdb/sqlite3.c     else if( isFts4 &amp;&amp; fts3IsSpecialColumn(z, &amp;nKey, &amp;zVal) ){</span>
<span class='curline'><a href='../S/185.html#L130771'>nKey</a>             130771 libdb/sqlite3.c           if( nKey==pOp-&gt;nOpt &amp;&amp; !sqlite3_strnicmp(z, pOp-&gt;zOpt, pOp-&gt;nOpt) ){</span>
<span class='curline'><a href='../S/185.html#L136384'>nKey</a>             136384 libdb/sqlite3.c       int nKey = pKey-&gt;n;</span>
<span class='curline'><a href='../S/185.html#L136389'>nKey</a>             136389 libdb/sqlite3.c         assert( nKey==4 );</span>
<span class='curline'><a href='../S/185.html#L136392'>nKey</a>             136392 libdb/sqlite3.c           for(nKey=5; zInput[nKey]&gt;='0' &amp;&amp; zInput[nKey]&lt;='9'; nKey++){</span>
<span class='curline'><a href='../S/185.html#L136393'>nKey</a>             136393 libdb/sqlite3.c             nNear = nNear * 10 + (zInput[nKey] - '0');</span>
<span class='curline'><a href='../S/185.html#L136402'>nKey</a>             136402 libdb/sqlite3.c       cNext = zInput[nKey];</span>
<span class='curline'><a href='../S/185.html#L136413'>nKey</a>             136413 libdb/sqlite3.c         *pnConsumed = (int)((zInput - z) + nKey);</span>
<span class='curline'><a href='../S/185.html#L137323'>nKey</a>             137323 libdb/sqlite3.c static int fts3StrHash(const void *pKey, int nKey){</span>
<span class='curline'><a href='../S/185.html#L137326'>nKey</a>             137326 libdb/sqlite3.c   if( nKey&lt;=0 ) nKey = (int) strlen(z);</span>
<span class='curline'><a href='../S/185.html#L137327'>nKey</a>             137327 libdb/sqlite3.c   while( nKey &gt; 0  ){</span>
<span class='curline'><a href='../S/185.html#L137329'>nKey</a>             137329 libdb/sqlite3.c     nKey--;</span>
<span class='curline'><a href='../S/185.html#L137341'>nKey</a>             137341 libdb/sqlite3.c static int fts3BinHash(const void *pKey, int nKey){</span>
<span class='curline'><a href='../S/185.html#L137344'>nKey</a>             137344 libdb/sqlite3.c   while( nKey-- &gt; 0 ){</span>
<span class='curline'><a href='../S/185.html#L137435'>nKey</a>             137435 libdb/sqlite3.c     int h = (*xHash)(elem-&gt;pKey, elem-&gt;nKey) &amp; (new_size-1);</span>
<span class='curline'><a href='../S/185.html#L137449'>nKey</a>             137449 libdb/sqlite3.c   int nKey,</span>
<span class='curline'><a href='../S/185.html#L137462'>nKey</a>             137462 libdb/sqlite3.c       if( (*xCompare)(elem-&gt;pKey,elem-&gt;nKey,pKey,nKey)==0 ){ </span>
<span class='curline'><a href='../S/185.html#L137511'>nKey</a>             137511 libdb/sqlite3.c   int nKey</span>
<span class='curline'><a href='../S/185.html#L137519'>nKey</a>             137519 libdb/sqlite3.c   h = (*xHash)(pKey,nKey);</span>
<span class='curline'><a href='../S/185.html#L137521'>nKey</a>             137521 libdb/sqlite3.c   return fts3FindElementByHash(pH,pKey,nKey, h &amp; (pH-&gt;htsize-1));</span>
<span class='curline'><a href='../S/185.html#L137529'>nKey</a>             137529 libdb/sqlite3.c SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey){</span>
<span class='curline'><a href='../S/185.html#L137532'>nKey</a>             137532 libdb/sqlite3.c   pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L137554'>nKey</a>             137554 libdb/sqlite3.c   int nKey,            /* Number of bytes in the key */</span>
<span class='curline'><a href='../S/185.html#L137566'>nKey</a>             137566 libdb/sqlite3.c   hraw = (*xHash)(pKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L137569'>nKey</a>             137569 libdb/sqlite3.c   elem = fts3FindElementByHash(pH,pKey,nKey,h);</span>
<span class='curline'><a href='../S/185.html#L137590'>nKey</a>             137590 libdb/sqlite3.c     new_elem-&gt;pKey = fts3HashMalloc( nKey );</span>
<span class='curline'><a href='../S/185.html#L137595'>nKey</a>             137595 libdb/sqlite3.c     memcpy((void*)new_elem-&gt;pKey, pKey, nKey);</span>
<span class='curline'><a href='../S/185.html#L137599'>nKey</a>             137599 libdb/sqlite3.c   new_elem-&gt;nKey = nKey;</span>
<span class='curline'><a href='../S/185.html#L141137'>nKey</a>             141137 libdb/sqlite3.c       int nKey = fts3HashKeysize(pE);</span>
<span class='curline'><a href='../S/185.html#L141138'>nKey</a>             141138 libdb/sqlite3.c       if( nTerm==0 || (nKey&gt;=nTerm &amp;&amp; 0==memcmp(zKey, zTerm, nTerm)) ){</span>
<span class='curline'><a href='../S/185.html#L143613'>nKey</a>             143613 libdb/sqlite3.c   int nKey,                       /* Number of bytes in nKey */</span>
<span class='curline'><a href='../S/185.html#L143663'>nKey</a>             143663 libdb/sqlite3.c         if( fts3TermCmp(zKey, nKey, reader.term.a, reader.term.n)&lt;=0 ){</span>
<span class='curline'><a href='../S/185.html#L144345'>nKey</a>             144345 libdb/sqlite3.c         int nKey = pCsr-&gt;nTerm;</span>
<span class='curline'><a href='../S/185.html#L144346'>nKey</a>             144346 libdb/sqlite3.c         rc = fts3IncrmergeLoad(p, iAbsLevel, iIdx-1, zKey, nKey, pWriter);</span>
<span class='curline'><a href='../S/186.html#L4670'>nKey</a>             4670 libdb/sqlite3.h   const void *pKey, int nKey     /* The key */</span>
<span class='curline'><a href='../S/186.html#L4675'>nKey</a>             4675 libdb/sqlite3.h   const void *pKey, int nKey     /* The key */</span>
<span class='curline'><a href='../S/186.html#L4688'>nKey</a>             4688 libdb/sqlite3.h   const void *pKey, int nKey     /* The new key */</span>
<span class='curline'><a href='../S/186.html#L4693'>nKey</a>             4693 libdb/sqlite3.h   const void *pKey, int nKey     /* The new key */</span>
</pre>
</body>
</html>
