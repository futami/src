<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>stack</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/199.html#L1163'>stack</a>            1163 libglibc/regex.c   fail_stack_elt_t *stack;</span>
<span class='curline'><a href='../S/199.html#L1188'>stack</a>            1188 libglibc/regex.c   fail_stack_elt_t *stack;</span>
<span class='curline'><a href='../S/199.html#L1206'>stack</a>            1206 libglibc/regex.c     fail_stack.stack = (fail_stack_elt_t *)				\</span>
<span class='curline'><a href='../S/199.html#L1209'>stack</a>            1209 libglibc/regex.c     if (fail_stack.stack == NULL)					\</span>
<span class='curline'><a href='../S/199.html#L1216'>stack</a>            1216 libglibc/regex.c # define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)</span>
<span class='curline'><a href='../S/199.html#L1237'>stack</a>            1237 libglibc/regex.c    : ((fail_stack).stack = (fail_stack_elt_t *)				\</span>
<span class='curline'><a href='../S/199.html#L1238'>stack</a>            1238 libglibc/regex.c         REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\</span>
<span class='curline'><a href='../S/199.html#L1242'>stack</a>            1242 libglibc/regex.c       (fail_stack).stack == NULL					\</span>
<span class='curline'><a href='../S/199.html#L1255'>stack</a>            1255 libglibc/regex.c    : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\</span>
<span class='curline'><a href='../S/199.html#L1262'>stack</a>            1262 libglibc/regex.c   fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)</span>
<span class='curline'><a href='../S/199.html#L1268'>stack</a>            1268 libglibc/regex.c   fail_stack.stack[fail_stack.avail++].integer = (item)</span>
<span class='curline'><a href='../S/199.html#L1274'>stack</a>            1274 libglibc/regex.c   fail_stack.stack[fail_stack.avail++] =  (item)</span>
<span class='curline'><a href='../S/199.html#L1278'>stack</a>            1278 libglibc/regex.c #define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer</span>
<span class='curline'><a href='../S/199.html#L1279'>stack</a>            1279 libglibc/regex.c #define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer</span>
<span class='curline'><a href='../S/199.html#L1280'>stack</a>            1280 libglibc/regex.c #define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]</span>
<span class='curline'><a href='../S/199.html#L1740'>stack</a>            1740 libglibc/regex.c   compile_stack_elt_t *stack;</span>
<span class='curline'><a href='../S/199.html#L1752'>stack</a>            1752 libglibc/regex.c #define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])</span>
<span class='curline'><a href='../S/199.html#L1878'>stack</a>            1878 libglibc/regex.c   return (free (compile_stack.stack), value)</span>
<span class='curline'><a href='../S/199.html#L1949'>stack</a>            1949 libglibc/regex.c   compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);</span>
<span class='curline'><a href='../S/199.html#L1950'>stack</a>            1950 libglibc/regex.c   if (compile_stack.stack == NULL)</span>
<span class='curline'><a href='../S/199.html#L2448'>stack</a>            2448 libglibc/regex.c                   RETALLOC (compile_stack.stack, compile_stack.size &lt;&lt; 1,</span>
<span class='curline'><a href='../S/199.html#L2450'>stack</a>            2450 libglibc/regex.c                   if (compile_stack.stack == NULL) return REG_ESPACE;</span>
<span class='curline'><a href='../S/199.html#L2936'>stack</a>            2936 libglibc/regex.c   free (compile_stack.stack);</span>
<span class='curline'><a href='../S/199.html#L2964'>stack</a>            2964 libglibc/regex.c 	if (! fail_stack.stack)</span>
<span class='curline'><a href='../S/199.html#L2965'>stack</a>            2965 libglibc/regex.c 	  fail_stack.stack</span>
<span class='curline'><a href='../S/199.html#L2969'>stack</a>            2969 libglibc/regex.c 	  fail_stack.stack</span>
<span class='curline'><a href='../S/199.html#L2970'>stack</a>            2970 libglibc/regex.c 	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,</span>
<span class='curline'><a href='../S/199.html#L2974'>stack</a>            2974 libglibc/regex.c 	if (! fail_stack.stack)</span>
<span class='curline'><a href='../S/199.html#L2975'>stack</a>            2975 libglibc/regex.c 	  fail_stack.stack</span>
<span class='curline'><a href='../S/199.html#L2979'>stack</a>            2979 libglibc/regex.c 	  fail_stack.stack</span>
<span class='curline'><a href='../S/199.html#L2980'>stack</a>            2980 libglibc/regex.c 	    = (fail_stack_elt_t *) realloc (fail_stack.stack,</span>
<span class='curline'><a href='../S/199.html#L3116'>stack</a>            3116 libglibc/regex.c     if (compile_stack.stack[this_element].regnum == regnum)</span>
<span class='curline'><a href='../S/199.html#L3247'>stack</a>            3247 libglibc/regex.c 	      p = fail_stack.stack[--fail_stack.avail].pointer;</span>
<span class='curline'><a href='../S/199.html#L3399'>stack</a>            3399 libglibc/regex.c 	      &amp;&amp; fail_stack.stack[fail_stack.avail - 1].pointer == p)</span>
<span class='curline'><a href='../S/199.html#L3763'>stack</a>            3763 libglibc/regex.c     REGEX_FREE_STACK (fail_stack.stack);				\</span>
<span class='curline'><a href='../S/240.html#L63'>stack</a>              63 libparser/C.c  } stack[MAXPIFSTACK], *cur;</span>
<span class='curline'><a href='../S/240.html#L610'>stack</a>             610 libparser/C.c  	cur = &amp;stack[piflevel];</span>
<span class='curline'><a href='../S/241.html#L81'>stack</a>              81 libparser/Cpp.c 	} stack[MAXCLASSSTACK];</span>
<span class='curline'><a href='../S/241.html#L86'>stack</a>              86 libparser/Cpp.c 	stack[0].classname = completename;</span>
<span class='curline'><a href='../S/241.html#L87'>stack</a>              87 libparser/Cpp.c 	stack[0].terminate = completename;</span>
<span class='curline'><a href='../S/241.html#L88'>stack</a>              88 libparser/Cpp.c 	stack[0].level = 0;</span>
<span class='curline'><a href='../S/241.html#L100'>stack</a>             100 libparser/Cpp.c 		if (cc == '~' &amp;&amp; level == stack[classlevel].level)</span>
<span class='curline'><a href='../S/241.html#L109'>stack</a>             109 libparser/Cpp.c 				} else if (level &gt; stack[classlevel].level || startequal || startmacro) {</span>
<span class='curline'><a href='../S/241.html#L111'>stack</a>             111 libparser/Cpp.c 				} else if (level == stack[classlevel].level &amp;&amp; !startmacro &amp;&amp; !startsharp &amp;&amp; !startequal) {</span>
<span class='curline'><a href='../S/241.html#L121'>stack</a>             121 libparser/Cpp.c 						if (strcmp(stack[classlevel].classname, savetok))</span>
<span class='curline'><a href='../S/241.html#L265'>stack</a>             265 libparser/Cpp.c 				char *p = stack[classlevel].terminate;</span>
<span class='curline'><a href='../S/241.html#L272'>stack</a>             272 libparser/Cpp.c 				stack[classlevel].classname = p;</span>
<span class='curline'><a href='../S/241.html#L275'>stack</a>             275 libparser/Cpp.c 				stack[classlevel].terminate = p;</span>
<span class='curline'><a href='../S/241.html#L276'>stack</a>             276 libparser/Cpp.c 				stack[classlevel].level = level;</span>
<span class='curline'><a href='../S/241.html#L296'>stack</a>             296 libparser/Cpp.c 			if (level &lt; stack[classlevel].level)</span>
<span class='curline'><a href='../S/241.html#L297'>stack</a>             297 libparser/Cpp.c 				*(stack[--classlevel].terminate) = 0;</span>
<span class='curline'><a href='../S/250.html#L55'>stack</a>              55 libparser/java.c 	} stack[MAXCLASSSTACK];</span>
<span class='curline'><a href='../S/250.html#L59'>stack</a>              59 libparser/java.c 	stack[0].classname = completename;</span>
<span class='curline'><a href='../S/250.html#L60'>stack</a>              60 libparser/java.c 	stack[0].terminate = completename;</span>
<span class='curline'><a href='../S/250.html#L61'>stack</a>              61 libparser/java.c 	stack[0].level = 0;</span>
<span class='curline'><a href='../S/250.html#L78'>stack</a>              78 libparser/java.c 				if (level == stack[classlevel].level &amp;&amp; !startequal)</span>
<span class='curline'><a href='../S/250.html#L80'>stack</a>              80 libparser/java.c 					if (strcmp(stack[classlevel].classname, token))</span>
<span class='curline'><a href='../S/250.html#L82'>stack</a>              82 libparser/java.c 				if (level &gt; stack[classlevel].level || startequal)</span>
<span class='curline'><a href='../S/250.html#L93'>stack</a>              93 libparser/java.c 				char *p = stack[classlevel].terminate;</span>
<span class='curline'><a href='../S/250.html#L100'>stack</a>             100 libparser/java.c 				stack[classlevel].classname = p;</span>
<span class='curline'><a href='../S/250.html#L103'>stack</a>             103 libparser/java.c 				stack[classlevel].terminate = p;</span>
<span class='curline'><a href='../S/250.html#L104'>stack</a>             104 libparser/java.c 				stack[classlevel].level = level;</span>
<span class='curline'><a href='../S/250.html#L116'>stack</a>             116 libparser/java.c 			if (level &lt; stack[classlevel].level)</span>
<span class='curline'><a href='../S/250.html#L117'>stack</a>             117 libparser/java.c 				*(stack[--classlevel].terminate) = 0;</span>
<span class='curline'><a href='../S/294.html#L488'>stack</a>             488 libutil/find.c static VARRAY *stack;				/**&lt; dynamic allocated array */</span>
<span class='curline'><a href='../S/294.html#L536'>stack</a>             536 libutil/find.c 	sp = varray_assign(stack, 0, 0);</span>
<span class='curline'><a href='../S/294.html#L712'>stack</a>             712 libutil/find.c 	stack = varray_open(sizeof(struct stack_entry), 50);</span>
<span class='curline'><a href='../S/294.html#L714'>stack</a>             714 libutil/find.c 	curp = varray_assign(stack, current_entry, 1);</span>
<span class='curline'><a href='../S/294.html#L859'>stack</a>             859 libutil/find.c 	struct stack_entry *curp = varray_assign(stack, current_entry, 1);</span>
<span class='curline'><a href='../S/294.html#L926'>stack</a>             926 libutil/find.c 				curp = varray_assign(stack, ++current_entry, 1);</span>
<span class='curline'><a href='../S/294.html#L943'>stack</a>             943 libutil/find.c 		curp = varray_assign(stack, --current_entry, 0);</span>
<span class='curline'><a href='../S/294.html#L978'>stack</a>             978 libutil/find.c 		if (stack)</span>
<span class='curline'><a href='../S/294.html#L979'>stack</a>             979 libutil/find.c 			varray_close(stack);</span>
</pre>
</body>
</html>
