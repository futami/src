<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>entry</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/125.html#L76'>entry</a>              76 htags/incop.c  	struct sh_entry *entry;</span>
<span class='curline'><a href='../S/125.html#L79'>entry</a>              79 htags/incop.c  	entry = strhash_assign(head_inc, HASH_KEY(file), 1);</span>
<span class='curline'><a href='../S/125.html#L80'>entry</a>              80 htags/incop.c  	data = entry-&gt;value;</span>
<span class='curline'><a href='../S/125.html#L86'>entry</a>              86 htags/incop.c  		data-&gt;name = entry-&gt;name;</span>
<span class='curline'><a href='../S/125.html#L93'>entry</a>              93 htags/incop.c  		entry-&gt;value = data;</span>
<span class='curline'><a href='../S/125.html#L107'>entry</a>             107 htags/incop.c  	struct sh_entry *entry = strhash_assign(head_inc, HASH_KEY(name), 0);</span>
<span class='curline'><a href='../S/125.html#L109'>entry</a>             109 htags/incop.c  	return entry ? entry-&gt;value : NULL;</span>
<span class='curline'><a href='../S/125.html#L119'>entry</a>             119 htags/incop.c  	struct sh_entry *entry = strhash_first(head_inc);</span>
<span class='curline'><a href='../S/125.html#L121'>entry</a>             121 htags/incop.c  	return entry ? entry-&gt;value : NULL;</span>
<span class='curline'><a href='../S/125.html#L131'>entry</a>             131 htags/incop.c  	struct sh_entry *entry = strhash_next(head_inc);</span>
<span class='curline'><a href='../S/125.html#L133'>entry</a>             133 htags/incop.c  	return entry ? entry-&gt;value : NULL;</span>
<span class='curline'><a href='../S/181.html#L84'>entry</a>              84 libdb/mpool.c  	int entry;</span>
<span class='curline'><a href='../S/181.html#L103'>entry</a>             103 libdb/mpool.c  	for (entry = 0; entry &lt; HASHSIZE; ++entry)</span>
<span class='curline'><a href='../S/181.html#L104'>entry</a>             104 libdb/mpool.c  		CIRCLEQ_INIT(&amp;mp-&gt;hqh[entry]);</span>
<span class='curline'><a href='../S/207.html#L56'>entry</a>              56 libltdl/libltdl/lt__argz_.h 				 char *before, const char *entry);</span>
<span class='curline'><a href='../S/207.html#L58'>entry</a>              58 libltdl/libltdl/lt__argz_.h 				 const char *entry);</span>
<span class='curline'><a href='../S/208.html#L79'>entry</a>              79 libltdl/libltdl/lt__dirent.h LT_SCOPE struct dirent *readdir		(DIR *entry);</span>
<span class='curline'><a href='../S/208.html#L80'>entry</a>              80 libltdl/libltdl/lt__dirent.h LT_SCOPE void		closedir	(DIR *entry);</span>
<span class='curline'><a href='../S/225.html#L132'>entry</a>             132 libltdl/lt__argz.c argz_insert (char **pargz, size_t *pargz_len, char *before, const char *entry)</span>
<span class='curline'><a href='../S/225.html#L136'>entry</a>             136 libltdl/lt__argz.c   assert (entry &amp;&amp; *entry);</span>
<span class='curline'><a href='../S/225.html#L141'>entry</a>             141 libltdl/lt__argz.c     return argz_append (pargz, pargz_len, entry, 1+ strlen (entry));</span>
<span class='curline'><a href='../S/225.html#L150'>entry</a>             150 libltdl/lt__argz.c     size_t entry_len	= 1+ strlen (entry);</span>
<span class='curline'><a href='../S/225.html#L166'>entry</a>             166 libltdl/lt__argz.c     memcpy  (before, entry, entry_len);</span>
<span class='curline'><a href='../S/225.html#L178'>entry</a>             178 libltdl/lt__argz.c argz_next (char *argz, size_t argz_len, const char *entry)</span>
<span class='curline'><a href='../S/225.html#L182'>entry</a>             182 libltdl/lt__argz.c   if (entry)</span>
<span class='curline'><a href='../S/225.html#L187'>entry</a>             187 libltdl/lt__argz.c 	      || ((argz &lt;= entry) &amp;&amp; (entry &lt; (argz + argz_len))));</span>
<span class='curline'><a href='../S/225.html#L191'>entry</a>             191 libltdl/lt__argz.c       entry = 1+ strchr (entry, EOS_CHAR);</span>
<span class='curline'><a href='../S/225.html#L195'>entry</a>             195 libltdl/lt__argz.c       return (entry &gt;= argz + argz_len) ? 0 : (char *) entry;</span>
<span class='curline'><a href='../S/226.html#L40'>entry</a>              40 libltdl/lt__dirent.c closedir (DIR *entry)</span>
<span class='curline'><a href='../S/226.html#L42'>entry</a>              42 libltdl/lt__dirent.c   assert (entry != (DIR *) NULL);</span>
<span class='curline'><a href='../S/226.html#L43'>entry</a>              43 libltdl/lt__dirent.c   FindClose (entry-&gt;hSearch);</span>
<span class='curline'><a href='../S/226.html#L44'>entry</a>              44 libltdl/lt__dirent.c   free (entry);</span>
<span class='curline'><a href='../S/226.html#L52'>entry</a>              52 libltdl/lt__dirent.c   DIR *entry;</span>
<span class='curline'><a href='../S/226.html#L58'>entry</a>              58 libltdl/lt__dirent.c   entry = (DIR *) malloc (sizeof(DIR));</span>
<span class='curline'><a href='../S/226.html#L59'>entry</a>              59 libltdl/lt__dirent.c   if (entry != (DIR *) 0)</span>
<span class='curline'><a href='../S/226.html#L61'>entry</a>              61 libltdl/lt__dirent.c       entry-&gt;firsttime = TRUE;</span>
<span class='curline'><a href='../S/226.html#L62'>entry</a>              62 libltdl/lt__dirent.c       entry-&gt;hSearch = FindFirstFile (file_spec, &amp;entry-&gt;Win32FindData);</span>
<span class='curline'><a href='../S/226.html#L64'>entry</a>              64 libltdl/lt__dirent.c       if (entry-&gt;hSearch == INVALID_HANDLE_VALUE)</span>
<span class='curline'><a href='../S/226.html#L68'>entry</a>              68 libltdl/lt__dirent.c 	      entry-&gt;hSearch = FindFirstFile (file_spec, &amp;entry-&gt;Win32FindData);</span>
<span class='curline'><a href='../S/226.html#L71'>entry</a>              71 libltdl/lt__dirent.c 	  if (entry-&gt;hSearch == INVALID_HANDLE_VALUE)</span>
<span class='curline'><a href='../S/226.html#L73'>entry</a>              73 libltdl/lt__dirent.c 	      entry = (free (entry), (DIR *) 0);</span>
<span class='curline'><a href='../S/226.html#L78'>entry</a>              78 libltdl/lt__dirent.c   return entry;</span>
<span class='curline'><a href='../S/226.html#L83'>entry</a>              83 libltdl/lt__dirent.c readdir (DIR *entry)</span>
<span class='curline'><a href='../S/226.html#L87'>entry</a>              87 libltdl/lt__dirent.c   if (entry == (DIR *) 0)</span>
<span class='curline'><a href='../S/226.html#L90'>entry</a>              90 libltdl/lt__dirent.c   if (!entry-&gt;firsttime)</span>
<span class='curline'><a href='../S/226.html#L92'>entry</a>              92 libltdl/lt__dirent.c       status = FindNextFile (entry-&gt;hSearch, &amp;entry-&gt;Win32FindData);</span>
<span class='curline'><a href='../S/226.html#L97'>entry</a>              97 libltdl/lt__dirent.c   entry-&gt;firsttime = FALSE;</span>
<span class='curline'><a href='../S/226.html#L98'>entry</a>              98 libltdl/lt__dirent.c   if (lt_strlcpy (entry-&gt;file_info.d_name, entry-&gt;Win32FindData.cFileName,</span>
<span class='curline'><a href='../S/226.html#L99'>entry</a>              99 libltdl/lt__dirent.c 	sizeof entry-&gt;file_info.d_name) &gt;= sizeof entry-&gt;file_info.d_name)</span>
<span class='curline'><a href='../S/226.html#L101'>entry</a>             101 libltdl/lt__dirent.c   entry-&gt;file_info.d_namlen = strlen (entry-&gt;file_info.d_name);</span>
<span class='curline'><a href='../S/226.html#L103'>entry</a>             103 libltdl/lt__dirent.c   return &amp;entry-&gt;file_info;</span>
<span class='curline'><a href='../S/220.html#L142'>entry</a>             142 libltdl/ltdl.c 				       char *before, const char *entry);</span>
<span class='curline'><a href='../S/220.html#L144'>entry</a>             144 libltdl/ltdl.c 				       const char *entry);</span>
<span class='curline'><a href='../S/220.html#L1722'>entry</a>            1722 libltdl/ltdl.c 		const char *entry)</span>
<span class='curline'><a href='../S/220.html#L1729'>entry</a>            1729 libltdl/ltdl.c     error = argz_insert (pargz, pargz_len, before, entry);</span>
<span class='curline'><a href='../S/220.html#L1731'>entry</a>            1731 libltdl/ltdl.c     error = argz_append (pargz, pargz_len, entry, 1 + strlen (entry));</span>
<span class='curline'><a href='../S/220.html#L1751'>entry</a>            1751 libltdl/ltdl.c lt_argz_insertinorder (char **pargz, size_t *pargz_len, const char *entry)</span>
<span class='curline'><a href='../S/220.html#L1757'>entry</a>            1757 libltdl/ltdl.c   assert (entry &amp;&amp; *entry);</span>
<span class='curline'><a href='../S/220.html#L1762'>entry</a>            1762 libltdl/ltdl.c 	int cmp = strcmp (entry, before);</span>
<span class='curline'><a href='../S/220.html#L1768'>entry</a>            1768 libltdl/ltdl.c   return lt_argz_insert (pargz, pargz_len, before, entry);</span>
<span class='curline'><a href='../S/256.html#L132'>entry</a>             132 libparser/parser.c 	struct lang_entry entry;</span>
<span class='curline'><a href='../S/256.html#L162'>entry</a>             162 libparser/parser.c 		pent-&gt;entry.lang_name = p;</span>
<span class='curline'><a href='../S/256.html#L218'>entry</a>             218 libparser/parser.c 		pent-&gt;entry.lt_dl_name = lt_dl_name;</span>
<span class='curline'><a href='../S/256.html#L219'>entry</a>             219 libparser/parser.c 		pent-&gt;entry.parser = (PVOID)GetProcAddress((HINSTANCE)pent-&gt;handle, parser_name);</span>
<span class='curline'><a href='../S/256.html#L234'>entry</a>             234 libparser/parser.c 		pent-&gt;entry.lt_dl_name = lt_dl_name;</span>
<span class='curline'><a href='../S/256.html#L235'>entry</a>             235 libparser/parser.c 		pent-&gt;entry.parser = lt_dlsym(pent-&gt;handle, parser_name);</span>
<span class='curline'><a href='../S/256.html#L237'>entry</a>             237 libparser/parser.c 		if (pent-&gt;entry.parser == NULL)</span>
<span class='curline'><a href='../S/256.html#L239'>entry</a>             239 libparser/parser.c 		pent-&gt;entry.parser_name = parser_name;</span>
<span class='curline'><a href='../S/256.html#L302'>entry</a>             302 libparser/parser.c 		if (strcmp(lang, pent-&gt;entry.lang_name) == 0)</span>
<span class='curline'><a href='../S/256.html#L303'>entry</a>             303 libparser/parser.c 			return &amp;pent-&gt;entry;</span>
<span class='curline'><a href='../S/304.html#L494'>entry</a>             494 libutil/gtagsop.c 		struct sh_entry *entry;</span>
<span class='curline'><a href='../S/304.html#L507'>entry</a>             507 libutil/gtagsop.c 		entry = strhash_assign(gtop-&gt;path_hash, tag, 1);</span>
<span class='curline'><a href='../S/304.html#L508'>entry</a>             508 libutil/gtagsop.c 		if (entry-&gt;value == NULL)</span>
<span class='curline'><a href='../S/304.html#L509'>entry</a>             509 libutil/gtagsop.c 			entry-&gt;value = varray_open(sizeof(int), 100);</span>
<span class='curline'><a href='../S/304.html#L510'>entry</a>             510 libutil/gtagsop.c 		*(int *)varray_append((VARRAY *)entry-&gt;value) = lno;</span>
<span class='curline'><a href='../S/304.html#L792'>entry</a>             792 libutil/gtagsop.c 		struct sh_entry *entry;</span>
<span class='curline'><a href='../S/304.html#L818'>entry</a>             818 libutil/gtagsop.c 			entry = strhash_assign(gtop-&gt;path_hash, tagline, 1);</span>
<span class='curline'><a href='../S/304.html#L820'>entry</a>             820 libutil/gtagsop.c 			if (entry-&gt;value == NULL) {</span>
<span class='curline'><a href='../S/304.html#L824'>entry</a>             824 libutil/gtagsop.c 				entry-&gt;value = strhash_strdup(gtop-&gt;path_hash, cp, 0);</span>
<span class='curline'><a href='../S/304.html#L840'>entry</a>             840 libutil/gtagsop.c 		for (entry = strhash_first(gtop-&gt;path_hash); entry != NULL; entry = strhash_next(gtop-&gt;path_hash))</span>
<span class='curline'><a href='../S/304.html#L841'>entry</a>             841 libutil/gtagsop.c 			gtop-&gt;path_array[i++] = entry-&gt;value;</span>
<span class='curline'><a href='../S/304.html#L1003'>entry</a>            1003 libutil/gtagsop.c 	struct sh_entry *entry;</span>
<span class='curline'><a href='../S/304.html#L1013'>entry</a>            1013 libutil/gtagsop.c 	for (entry = strhash_first(gtop-&gt;path_hash); entry; entry = strhash_next(gtop-&gt;path_hash)) {</span>
<span class='curline'><a href='../S/304.html#L1014'>entry</a>            1014 libutil/gtagsop.c 		VARRAY *vb = (VARRAY *)entry-&gt;value;</span>
<span class='curline'><a href='../S/304.html#L1016'>entry</a>            1016 libutil/gtagsop.c 		const char *key = entry-&gt;name;</span>
<span class='curline'><a href='../S/304.html#L1027'>entry</a>            1027 libutil/gtagsop.c 			if ((key = locatestring(entry-&gt;name, ".", MATCH_LAST)) != NULL)</span>
<span class='curline'><a href='../S/304.html#L1029'>entry</a>            1029 libutil/gtagsop.c 			else if ((key = locatestring(entry-&gt;name, "::", MATCH_LAST)) != NULL)</span>
<span class='curline'><a href='../S/304.html#L1032'>entry</a>            1032 libutil/gtagsop.c 				key = entry-&gt;name;</span>
<span class='curline'><a href='../S/304.html#L1041'>entry</a>            1041 libutil/gtagsop.c 			strbuf_puts(gtop-&gt;sb, compress(entry-&gt;name, key, gtop-&gt;sb_compress));</span>
<span class='curline'><a href='../S/304.html#L1043'>entry</a>            1043 libutil/gtagsop.c 			strbuf_puts(gtop-&gt;sb, entry-&gt;name);</span>
<span class='curline'><a href='../S/313.html#L119'>entry</a>             119 libutil/linetable.c 	int *entry;</span>
<span class='curline'><a href='../S/313.html#L123'>entry</a>             123 libutil/linetable.c 	entry = varray_assign(vb, lineno - 1, 1);</span>
<span class='curline'><a href='../S/313.html#L124'>entry</a>             124 libutil/linetable.c 	*entry = offset;</span>
<span class='curline'><a href='../S/342.html#L112'>entry</a>             112 libutil/strhash.c 	struct sh_entry *entry;</span>
<span class='curline'><a href='../S/342.html#L117'>entry</a>             117 libutil/strhash.c 	SLIST_FOREACH(entry, head, ptr)</span>
<span class='curline'><a href='../S/342.html#L118'>entry</a>             118 libutil/strhash.c 		if (strcmp(entry-&gt;name, name) == 0)</span>
<span class='curline'><a href='../S/342.html#L123'>entry</a>             123 libutil/strhash.c 	if (entry == NULL &amp;&amp; force) {</span>
<span class='curline'><a href='../S/342.html#L124'>entry</a>             124 libutil/strhash.c 		entry = pool_malloc(sh-&gt;pool, sizeof(struct sh_entry));</span>
<span class='curline'><a href='../S/342.html#L125'>entry</a>             125 libutil/strhash.c 		entry-&gt;name = pool_strdup(sh-&gt;pool, name, 0);</span>
<span class='curline'><a href='../S/342.html#L126'>entry</a>             126 libutil/strhash.c 		entry-&gt;value = NULL;</span>
<span class='curline'><a href='../S/342.html#L127'>entry</a>             127 libutil/strhash.c 		SLIST_INSERT_HEAD(head, entry, ptr);</span>
<span class='curline'><a href='../S/342.html#L130'>entry</a>             130 libutil/strhash.c 	return entry;</span>
<span class='curline'><a href='../S/342.html#L166'>entry</a>             166 libutil/strhash.c 	struct sh_entry *entry = NULL;</span>
<span class='curline'><a href='../S/342.html#L169'>entry</a>             169 libutil/strhash.c 		entry = sh-&gt;cur_entry;</span>
<span class='curline'><a href='../S/342.html#L170'>entry</a>             170 libutil/strhash.c 		if (entry == NULL) {</span>
<span class='curline'><a href='../S/342.html#L172'>entry</a>             172 libutil/strhash.c 				entry = SLIST_FIRST(&amp;sh-&gt;htab[sh-&gt;cur_bucket]);</span>
<span class='curline'><a href='../S/342.html#L173'>entry</a>             173 libutil/strhash.c 				if (entry)</span>
<span class='curline'><a href='../S/342.html#L177'>entry</a>             177 libutil/strhash.c 		sh-&gt;cur_entry = (entry) ? SLIST_NEXT(entry, ptr) : NULL;</span>
<span class='curline'><a href='../S/342.html#L179'>entry</a>             179 libutil/strhash.c 	return entry;</span>
</pre>
</body>
</html>
