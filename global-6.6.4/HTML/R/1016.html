<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>MemPage</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/185.html#L51458'>MemPage</a>          51458 libdb/sqlite3.c typedef struct MemPage MemPage;</span>
<span class='curline'><a href='../S/185.html#L51531'>MemPage</a>          51531 libdb/sqlite3.c #define EXTRA_SIZE sizeof(MemPage)</span>
<span class='curline'><a href='../S/185.html#L51637'>MemPage</a>          51637 libdb/sqlite3.c   MemPage *pPage1;      /* First page of the database */</span>
<span class='curline'><a href='../S/185.html#L51736'>MemPage</a>          51736 libdb/sqlite3.c   MemPage *apPage[BTCURSOR_MAX_DEPTH];  /* Pages from root to current page */</span>
<span class='curline'><a href='../S/185.html#L52620'>MemPage</a>          52620 libdb/sqlite3.c static void releasePage(MemPage *pPage);  /* Forward reference */</span>
<span class='curline'><a href='../S/185.html#L53136'>MemPage</a>          53136 libdb/sqlite3.c static u8 *findOverflowCell(MemPage *pPage, int iCell){</span>
<span class='curline'><a href='../S/185.html#L53159'>MemPage</a>          53159 libdb/sqlite3.c   MemPage *pPage,         /* Page containing the cell */</span>
<span class='curline'><a href='../S/185.html#L53226'>MemPage</a>          53226 libdb/sqlite3.c   MemPage *pPage,         /* Page containing the cell */</span>
<span class='curline'><a href='../S/185.html#L53239'>MemPage</a>          53239 libdb/sqlite3.c static u16 cellSizePtr(MemPage *pPage, u8 *pCell){</span>
<span class='curline'><a href='../S/185.html#L53297'>MemPage</a>          53297 libdb/sqlite3.c static u16 cellSize(MemPage *pPage, int iCell){</span>
<span class='curline'><a href='../S/185.html#L53308'>MemPage</a>          53308 libdb/sqlite3.c static void ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell, int *pRC){</span>
<span class='curline'><a href='../S/185.html#L53327'>MemPage</a>          53327 libdb/sqlite3.c static int defragmentPage(MemPage *pPage){</span>
<span class='curline'><a href='../S/185.html#L53417'>MemPage</a>          53417 libdb/sqlite3.c static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){</span>
<span class='curline'><a href='../S/185.html#L53524'>MemPage</a>          53524 libdb/sqlite3.c static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){</span>
<span class='curline'><a href='../S/185.html#L53622'>MemPage</a>          53622 libdb/sqlite3.c static int decodeFlags(MemPage *pPage, int flagByte){</span>
<span class='curline'><a href='../S/185.html#L53659'>MemPage</a>          53659 libdb/sqlite3.c static int btreeInitPage(MemPage *pPage){</span>
<span class='curline'><a href='../S/185.html#L53771'>MemPage</a>          53771 libdb/sqlite3.c static void zeroPage(MemPage *pPage, int flags){</span>
<span class='curline'><a href='../S/185.html#L53807'>MemPage</a>          53807 libdb/sqlite3.c static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){</span>
<span class='curline'><a href='../S/185.html#L53808'>MemPage</a>          53808 libdb/sqlite3.c   MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);</span>
<span class='curline'><a href='../S/185.html#L53831'>MemPage</a>          53831 libdb/sqlite3.c   MemPage **ppPage,    /* Return the page in this parameter */</span>
<span class='curline'><a href='../S/185.html#L53850'>MemPage</a>          53850 libdb/sqlite3.c static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){</span>
<span class='curline'><a href='../S/185.html#L53884'>MemPage</a>          53884 libdb/sqlite3.c   MemPage **ppPage,               /* Write the page pointer here */</span>
<span class='curline'><a href='../S/185.html#L53912'>MemPage</a>          53912 libdb/sqlite3.c static void releasePage(MemPage *pPage){</span>
<span class='curline'><a href='../S/185.html#L53933'>MemPage</a>          53933 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L53934'>MemPage</a>          53934 libdb/sqlite3.c   pPage = (MemPage *)sqlite3PagerGetExtra(pData);</span>
<span class='curline'><a href='../S/185.html#L54645'>MemPage</a>          54645 libdb/sqlite3.c   MemPage *pPage1;     /* Page 1 of the database file */</span>
<span class='curline'><a href='../S/185.html#L54826'>MemPage</a>          54826 libdb/sqlite3.c     MemPage *pPage1 = pBt-&gt;pPage1;</span>
<span class='curline'><a href='../S/185.html#L54840'>MemPage</a>          54840 libdb/sqlite3.c   MemPage *pP1;</span>
<span class='curline'><a href='../S/185.html#L55027'>MemPage</a>          55027 libdb/sqlite3.c       MemPage *pPage1 = pBt-&gt;pPage1;</span>
<span class='curline'><a href='../S/185.html#L55072'>MemPage</a>          55072 libdb/sqlite3.c static int setChildPtrmaps(MemPage *pPage){</span>
<span class='curline'><a href='../S/185.html#L55122'>MemPage</a>          55122 libdb/sqlite3.c static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){</span>
<span class='curline'><a href='../S/185.html#L55184'>MemPage</a>          55184 libdb/sqlite3.c   MemPage *pDbPage,        /* Open page to move */</span>
<span class='curline'><a href='../S/185.html#L55190'>MemPage</a>          55190 libdb/sqlite3.c   MemPage *pPtrPage;   /* The page that contains a pointer to pDbPage */</span>
<span class='curline'><a href='../S/185.html#L55256'>MemPage</a>          55256 libdb/sqlite3.c static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);</span>
<span class='curline'><a href='../S/185.html#L55307'>MemPage</a>          55307 libdb/sqlite3.c         MemPage *pFreePg;</span>
<span class='curline'><a href='../S/185.html#L55317'>MemPage</a>          55317 libdb/sqlite3.c       MemPage *pLastPg;</span>
<span class='curline'><a href='../S/185.html#L55338'>MemPage</a>          55338 libdb/sqlite3.c         MemPage *pFreePg;</span>
<span class='curline'><a href='../S/185.html#L55695'>MemPage</a>          55695 libdb/sqlite3.c   MemPage *pPage1;</span>
<span class='curline'><a href='../S/185.html#L56092'>MemPage</a>          56092 libdb/sqlite3.c   MemPage **ppPage,            /* OUT: MemPage handle (may be NULL) */</span>
<span class='curline'><a href='../S/185.html#L56096'>MemPage</a>          56096 libdb/sqlite3.c   MemPage *pPage = 0;</span>
<span class='curline'><a href='../S/185.html#L56218'>MemPage</a>          56218 libdb/sqlite3.c   MemPage *pPage = pCur-&gt;apPage[pCur-&gt;iPage]; /* Btree page of current entry */</span>
<span class='curline'><a href='../S/185.html#L56515'>MemPage</a>          56515 libdb/sqlite3.c   MemPage *pNewPage;</span>
<span class='curline'><a href='../S/185.html#L56548'>MemPage</a>          56548 libdb/sqlite3.c static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){</span>
<span class='curline'><a href='../S/185.html#L56616'>MemPage</a>          56616 libdb/sqlite3.c   MemPage *pRoot;</span>
<span class='curline'><a href='../S/185.html#L56691'>MemPage</a>          56691 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L56716'>MemPage</a>          56716 libdb/sqlite3.c   MemPage *pPage = 0;</span>
<span class='curline'><a href='../S/185.html#L56885'>MemPage</a>          56885 libdb/sqlite3.c     MemPage *pPage = pCur-&gt;apPage[pCur-&gt;iPage];</span>
<span class='curline'><a href='../S/185.html#L57070'>MemPage</a>          57070 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L57135'>MemPage</a>          57135 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L57179'>MemPage</a>          57179 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L57279'>MemPage</a>          57279 libdb/sqlite3.c   MemPage **ppPage,      /* Store pointer to the allocated page here */</span>
<span class='curline'><a href='../S/185.html#L57284'>MemPage</a>          57284 libdb/sqlite3.c   MemPage *pPage1;</span>
<span class='curline'><a href='../S/185.html#L57288'>MemPage</a>          57288 libdb/sqlite3.c   MemPage *pTrunk = 0;</span>
<span class='curline'><a href='../S/185.html#L57289'>MemPage</a>          57289 libdb/sqlite3.c   MemPage *pPrevTrunk = 0;</span>
<span class='curline'><a href='../S/185.html#L57407'>MemPage</a>          57407 libdb/sqlite3.c           MemPage *pNewTrunk;</span>
<span class='curline'><a href='../S/185.html#L57539'>MemPage</a>          57539 libdb/sqlite3.c       MemPage *pPg = 0;</span>
<span class='curline'><a href='../S/185.html#L57596'>MemPage</a>          57596 libdb/sqlite3.c static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){</span>
<span class='curline'><a href='../S/185.html#L57597'>MemPage</a>          57597 libdb/sqlite3.c   MemPage *pTrunk = 0;                /* Free-list trunk page */</span>
<span class='curline'><a href='../S/185.html#L57599'>MemPage</a>          57599 libdb/sqlite3.c   MemPage *pPage1 = pBt-&gt;pPage1;      /* Local reference to page 1 */</span>
<span class='curline'><a href='../S/185.html#L57600'>MemPage</a>          57600 libdb/sqlite3.c   MemPage *pPage;                     /* Page being freed. May be NULL. */</span>
<span class='curline'><a href='../S/185.html#L57718'>MemPage</a>          57718 libdb/sqlite3.c static void freePage(MemPage *pPage, int *pRC){</span>
<span class='curline'><a href='../S/185.html#L57730'>MemPage</a>          57730 libdb/sqlite3.c   MemPage *pPage,          /* The page that contains the Cell */</span>
<span class='curline'><a href='../S/185.html#L57757'>MemPage</a>          57757 libdb/sqlite3.c     MemPage *pOvfl = 0;</span>
<span class='curline'><a href='../S/185.html#L57809'>MemPage</a>          57809 libdb/sqlite3.c   MemPage *pPage,                /* The page that contains the cell */</span>
<span class='curline'><a href='../S/185.html#L57820'>MemPage</a>          57820 libdb/sqlite3.c   MemPage *pOvfl = 0;</span>
<span class='curline'><a href='../S/185.html#L57821'>MemPage</a>          57821 libdb/sqlite3.c   MemPage *pToRelease = 0;</span>
<span class='curline'><a href='../S/185.html#L57999'>MemPage</a>          57999 libdb/sqlite3.c static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){</span>
<span class='curline'><a href='../S/185.html#L58046'>MemPage</a>          58046 libdb/sqlite3.c   MemPage *pPage,   /* Page into which we are copying */</span>
<span class='curline'><a href='../S/185.html#L58129'>MemPage</a>          58129 libdb/sqlite3.c   MemPage *pPage,   /* The page to be assembled */</span>
<span class='curline'><a href='../S/185.html#L58206'>MemPage</a>          58206 libdb/sqlite3.c static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){</span>
<span class='curline'><a href='../S/185.html#L58208'>MemPage</a>          58208 libdb/sqlite3.c   MemPage *pNew;                       /* Newly allocated page */</span>
<span class='curline'><a href='../S/185.html#L58293'>MemPage</a>          58293 libdb/sqlite3.c static int ptrmapCheckPages(MemPage **apPage, int nPage){</span>
<span class='curline'><a href='../S/185.html#L58298'>MemPage</a>          58298 libdb/sqlite3.c     MemPage *pPage = apPage[i];</span>
<span class='curline'><a href='../S/185.html#L58346'>MemPage</a>          58346 libdb/sqlite3.c static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){</span>
<span class='curline'><a href='../S/185.html#L58431'>MemPage</a>          58431 libdb/sqlite3.c   MemPage *pParent,               /* Parent page of siblings being balanced */</span>
<span class='curline'><a href='../S/185.html#L58453'>MemPage</a>          58453 libdb/sqlite3.c   MemPage *apOld[NB];          /* pPage and up to two siblings */</span>
<span class='curline'><a href='../S/185.html#L58454'>MemPage</a>          58454 libdb/sqlite3.c   MemPage *apCopy[NB];         /* Private copies of apOld[] pages */</span>
<span class='curline'><a href='../S/185.html#L58455'>MemPage</a>          58455 libdb/sqlite3.c   MemPage *apNew[NB+2];        /* pPage and up to NB siblings after balancing */</span>
<span class='curline'><a href='../S/185.html#L58521'>MemPage</a>          58521 libdb/sqlite3.c       memset(apOld, 0, (i+1)*sizeof(MemPage*));</span>
<span class='curline'><a href='../S/185.html#L58555'>MemPage</a>          58555 libdb/sqlite3.c           memset(apOld, 0, (i+1)*sizeof(MemPage*));</span>
<span class='curline'><a href='../S/185.html#L58573'>MemPage</a>          58573 libdb/sqlite3.c   k = pBt-&gt;pageSize + ROUND8(sizeof(MemPage));</span>
<span class='curline'><a href='../S/185.html#L58613'>MemPage</a>          58613 libdb/sqlite3.c     MemPage *pOld = apCopy[i] = (MemPage*)&amp;aSpace1[pBt-&gt;pageSize + k*i];</span>
<span class='curline'><a href='../S/185.html#L58614'>MemPage</a>          58614 libdb/sqlite3.c     memcpy(pOld, apOld[i], sizeof(MemPage));</span>
<span class='curline'><a href='../S/185.html#L58760'>MemPage</a>          58760 libdb/sqlite3.c     MemPage *pNew;</span>
<span class='curline'><a href='../S/185.html#L58818'>MemPage</a>          58818 libdb/sqlite3.c       MemPage *pT;</span>
<span class='curline'><a href='../S/185.html#L58841'>MemPage</a>          58841 libdb/sqlite3.c     MemPage *pNew = apNew[i];</span>
<span class='curline'><a href='../S/185.html#L58967'>MemPage</a>          58967 libdb/sqlite3.c     MemPage *pNew = apNew[0];</span>
<span class='curline'><a href='../S/185.html#L58968'>MemPage</a>          58968 libdb/sqlite3.c     MemPage *pOld = apCopy[0];</span>
<span class='curline'><a href='../S/185.html#L59084'>MemPage</a>          59084 libdb/sqlite3.c static int balance_deeper(MemPage *pRoot, MemPage **ppChild){</span>
<span class='curline'><a href='../S/185.html#L59086'>MemPage</a>          59086 libdb/sqlite3.c   MemPage *pChild = 0;           /* Pointer to a new child page */</span>
<span class='curline'><a href='../S/185.html#L59152'>MemPage</a>          59152 libdb/sqlite3.c     MemPage *pPage = pCur-&gt;apPage[iPage];</span>
<span class='curline'><a href='../S/185.html#L59175'>MemPage</a>          59175 libdb/sqlite3.c       MemPage * const pParent = pCur-&gt;apPage[iPage-1];</span>
<span class='curline'><a href='../S/185.html#L59288'>MemPage</a>          59288 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L59430'>MemPage</a>          59430 libdb/sqlite3.c   MemPage *pPage;                      /* Page to delete cell from */</span>
<span class='curline'><a href='../S/185.html#L59493'>MemPage</a>          59493 libdb/sqlite3.c     MemPage *pLeaf = pCur-&gt;apPage[pCur-&gt;iPage];</span>
<span class='curline'><a href='../S/185.html#L59551'>MemPage</a>          59551 libdb/sqlite3.c   MemPage *pRoot;</span>
<span class='curline'><a href='../S/185.html#L59568'>MemPage</a>          59568 libdb/sqlite3.c     MemPage *pPageMove; /* The page to move to. */</span>
<span class='curline'><a href='../S/185.html#L59709'>MemPage</a>          59709 libdb/sqlite3.c   MemPage *pPage;</span>
<span class='curline'><a href='../S/185.html#L59814'>MemPage</a>          59814 libdb/sqlite3.c   MemPage *pPage = 0;</span>
<span class='curline'><a href='../S/185.html#L59866'>MemPage</a>          59866 libdb/sqlite3.c         MemPage *pMove;</span>
<span class='curline'><a href='../S/185.html#L60011'>MemPage</a>          60011 libdb/sqlite3.c     MemPage *pPage;                    /* Current page of the b-tree */</span>
<span class='curline'><a href='../S/185.html#L60268'>MemPage</a>          60268 libdb/sqlite3.c   MemPage *pPage;</span>
</pre>
</body>
</html>
