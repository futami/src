<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>aIndex</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1.html#L50'>aIndex</a>             50 action_plugin.cpp ACTION_PLUGIN* ACTION_PLUGINS::GetAction( int aIndex )</span>
<span class='curline'><a href='../S/1.html#L52'>aIndex</a>             52 action_plugin.cpp     return m_actionsList[aIndex];</span>
<span class='curline'><a href='../S/1.html#L70'>aIndex</a>             70 action_plugin.cpp void ACTION_PLUGINS::SetActionMenu( int aIndex, int idMenu )</span>
<span class='curline'><a href='../S/1.html#L72'>aIndex</a>             72 action_plugin.cpp     m_actionsList[aIndex]-&gt;m_actionMenuId = idMenu;</span>
<span class='curline'><a href='../S/2.html#L163'>aIndex</a>            163 action_plugin.h     static void SetActionMenu( int aIndex, int idMenu );</span>
<span class='curline'><a href='../S/2.html#L202'>aIndex</a>            202 action_plugin.h     static ACTION_PLUGIN* GetAction( int aIndex );</span>
<span class='curline'><a href='../S/17.html#L40'>aIndex</a>             40 array_creator.cpp static void TransformItem( const ARRAY_OPTIONS&amp; aArrOpts, int aIndex, BOARD_ITEM&amp; aItem )</span>
<span class='curline'><a href='../S/17.html#L42'>aIndex</a>             42 array_creator.cpp     const ARRAY_OPTIONS::TRANSFORM transform = aArrOpts.GetTransform( aIndex, aItem.GetPosition() );</span>
<span class='curline'><a href='../S/19.html#L63'>aIndex</a>             63 array_pad_name_provider.cpp wxString ARRAY_PAD_NAME_PROVIDER::getNextName( int&amp; aIndex, const std::set&lt;wxString&gt;&amp; aExisting )</span>
<span class='curline'><a href='../S/19.html#L69'>aIndex</a>             69 array_pad_name_provider.cpp         next_name = m_arrayOpts.GetItemNumber( aIndex );</span>
<span class='curline'><a href='../S/19.html#L70'>aIndex</a>             70 array_pad_name_provider.cpp         aIndex++;</span>
<span class='curline'><a href='../S/20.html#L57'>aIndex</a>             57 array_pad_name_provider.h     wxString getNextName( int&amp; aIndex, const std::set&lt;wxString&gt;&amp; aExisting );</span>
<span class='curline'><a href='../S/35.html#L858'>aIndex</a>            858 board_design_settings.cpp void BOARD_DESIGN_SETTINGS::SetViaSizeIndex( unsigned aIndex )</span>
<span class='curline'><a href='../S/35.html#L860'>aIndex</a>            860 board_design_settings.cpp     m_viaSizeIndex = std::min( aIndex, (unsigned) m_ViasDimensionsList.size() );</span>
<span class='curline'><a href='../S/35.html#L878'>aIndex</a>            878 board_design_settings.cpp void BOARD_DESIGN_SETTINGS::SetTrackWidthIndex( unsigned aIndex )</span>
<span class='curline'><a href='../S/35.html#L880'>aIndex</a>            880 board_design_settings.cpp     m_trackWidthIndex = std::min( aIndex, (unsigned) m_TrackWidthList.size() );</span>
<span class='curline'><a href='../S/35.html#L885'>aIndex</a>            885 board_design_settings.cpp void BOARD_DESIGN_SETTINGS::SetDiffPairIndex( unsigned aIndex )</span>
<span class='curline'><a href='../S/35.html#L887'>aIndex</a>            887 board_design_settings.cpp     m_diffPairIndex = std::min( aIndex, (unsigned) 8 );</span>
<span class='curline'><a href='../S/40.html#L372'>aIndex</a>            372 board_stackup_manager/class_board_stackup.cpp BOARD_STACKUP_ITEM* BOARD_STACKUP::GetStackupLayer( int aIndex )</span>
<span class='curline'><a href='../S/40.html#L374'>aIndex</a>            374 board_stackup_manager/class_board_stackup.cpp     if( aIndex &lt; 0 || aIndex &gt;= GetCount() )</span>
<span class='curline'><a href='../S/40.html#L377'>aIndex</a>            377 board_stackup_manager/class_board_stackup.cpp     return GetList()[aIndex];</span>
<span class='curline'><a href='../S/41.html#L253'>aIndex</a>            253 board_stackup_manager/class_board_stackup.h     BOARD_STACKUP_ITEM* GetStackupLayer( int aIndex );</span>
<span class='curline'><a href='../S/57.html#L257'>aIndex</a>            257 class_board.cpp bool BOARD::SetLayerDescr( PCB_LAYER_ID aIndex, const LAYER&amp; aLayer )</span>
<span class='curline'><a href='../S/57.html#L259'>aIndex</a>            259 class_board.cpp     if( unsigned( aIndex ) &lt; arrayDim( m_Layer ) )</span>
<span class='curline'><a href='../S/57.html#L261'>aIndex</a>            261 class_board.cpp         m_Layer[ aIndex ] = aLayer;</span>
<span class='curline'><a href='../S/57.html#L1809'>aIndex</a>           1809 class_board.cpp D_PAD* BOARD::GetPad( unsigned aIndex ) const</span>
<span class='curline'><a href='../S/57.html#L1817'>aIndex</a>           1817 class_board.cpp             if( count == aIndex )</span>
<span class='curline'><a href='../S/58.html#L662'>aIndex</a>            662 class_board.h      bool SetLayerDescr( PCB_LAYER_ID aIndex, const LAYER&amp; aLayer );</span>
<span class='curline'><a href='../S/58.html#L707'>aIndex</a>            707 class_board.h      D_PAD* GetPad( unsigned aIndex ) const;</span>
<span class='curline'><a href='../S/83.html#L94'>aIndex</a>             94 cleanup_item.h     CLEANUP_ITEM* GetItem( int aIndex ) override</span>
<span class='curline'><a href='../S/83.html#L96'>aIndex</a>             96 cleanup_item.h         return m_sourceVector-&gt;at( aIndex );</span>
<span class='curline'><a href='../S/83.html#L99'>aIndex</a>             99 cleanup_item.h     void DeleteItem( int aIndex, bool aDeep ) override</span>
<span class='curline'><a href='../S/83.html#L103'>aIndex</a>            103 cleanup_item.h             CLEANUP_ITEM* item = m_sourceVector-&gt;at( aIndex );</span>
<span class='curline'><a href='../S/83.html#L106'>aIndex</a>            106 cleanup_item.h             m_sourceVector-&gt;erase( m_sourceVector-&gt;begin() + aIndex );</span>
<span class='curline'><a href='../S/93.html#L451'>aIndex</a>            451 connectivity/connectivity_items.h     CN_ITEM* operator[] ( int aIndex ) { return m_items[aIndex]; }</span>
<span class='curline'><a href='../S/330.html#L212'>aIndex</a>            212 dialogs/panel_fp_lib_table.cpp     LIB_TABLE_ROW* at( size_t aIndex ) override { return &amp;rows.at( aIndex ); }</span>
<span class='curline'><a href='../S/397.html#L147'>aIndex</a>            147 drc/drc_provider.h     DRC_ITEM* GetItem( int aIndex ) override</span>
<span class='curline'><a href='../S/397.html#L149'>aIndex</a>            149 drc/drc_provider.h         MARKER_PCB* marker = m_filteredMarkers[ aIndex ];</span>
<span class='curline'><a href='../S/397.html#L154'>aIndex</a>            154 drc/drc_provider.h     void DeleteItem( int aIndex, bool aDeep ) override</span>
<span class='curline'><a href='../S/397.html#L156'>aIndex</a>            156 drc/drc_provider.h         MARKER_PCB* marker = m_filteredMarkers[ aIndex ];</span>
<span class='curline'><a href='../S/397.html#L157'>aIndex</a>            157 drc/drc_provider.h         m_filteredMarkers.erase( m_filteredMarkers.begin() + aIndex );</span>
<span class='curline'><a href='../S/397.html#L232'>aIndex</a>            232 drc/drc_provider.h     DRC_ITEM* GetItem( int aIndex ) override</span>
<span class='curline'><a href='../S/397.html#L234'>aIndex</a>            234 drc/drc_provider.h         return (m_filteredVector)[aIndex];</span>
<span class='curline'><a href='../S/397.html#L237'>aIndex</a>            237 drc/drc_provider.h     void DeleteItem( int aIndex, bool aDeep ) override</span>
<span class='curline'><a href='../S/397.html#L239'>aIndex</a>            239 drc/drc_provider.h         DRC_ITEM* item = m_filteredVector[aIndex];</span>
<span class='curline'><a href='../S/397.html#L240'>aIndex</a>            240 drc/drc_provider.h         m_filteredVector.erase( m_filteredVector.begin() + aIndex );</span>
<span class='curline'><a href='../S/419.html#L235'>aIndex</a>            235 exporters/export_vrml.cpp     VRML_COLOR&amp; GetColor( VRML_COLOR_INDEX aIndex )</span>
<span class='curline'><a href='../S/419.html#L237'>aIndex</a>            237 exporters/export_vrml.cpp         return colors[aIndex];</span>
<span class='curline'><a href='../S/446.html#L47'>aIndex</a>             47 footprint_wizard.cpp FOOTPRINT_WIZARD* FOOTPRINT_WIZARD_LIST::GetWizard( int aIndex )</span>
<span class='curline'><a href='../S/446.html#L49'>aIndex</a>             49 footprint_wizard.cpp     return m_FootprintWizards[aIndex];</span>
<span class='curline'><a href='../S/447.html#L215'>aIndex</a>            215 footprint_wizard.h     static FOOTPRINT_WIZARD*    GetWizard( int aIndex );</span>
<span class='curline'><a href='../S/522.html#L132'>aIndex</a>            132 netlist_reader/pcb_netlist.h     const COMPONENT_NET&amp; GetNet( unsigned aIndex ) const { return m_nets[aIndex]; }</span>
<span class='curline'><a href='../S/522.html#L237'>aIndex</a>            237 netlist_reader/pcb_netlist.h     COMPONENT* GetComponent( unsigned aIndex ) { return &amp;m_components[ aIndex ]; }</span>
<span class='curline'><a href='../S/595.html#L138'>aIndex</a>            138 pcb_parser.cpp void PCB_PARSER::pushValueIntoMap( int aIndex, int aValue )</span>
<span class='curline'><a href='../S/595.html#L143'>aIndex</a>            143 pcb_parser.cpp     if( (int)m_netCodes.size() &lt;= aIndex )</span>
<span class='curline'><a href='../S/595.html#L144'>aIndex</a>            144 pcb_parser.cpp         m_netCodes.resize( aIndex+1 );</span>
<span class='curline'><a href='../S/595.html#L146'>aIndex</a>            146 pcb_parser.cpp     m_netCodes[aIndex] = aValue;</span>
<span class='curline'><a href='../S/596.html#L101'>aIndex</a>            101 pcb_parser.h       void pushValueIntoMap( int aIndex, int aValue );</span>
<span class='curline'><a href='../S/661.html#L534'>aIndex</a>            534 router/pns_line.cpp void LINE::dragCorner45( const VECTOR2I&amp; aP, int aIndex )</span>
<span class='curline'><a href='../S/661.html#L538'>aIndex</a>            538 router/pns_line.cpp     VECTOR2I snapped = snapDraggedCorner( m_line, aP, aIndex );</span>
<span class='curline'><a href='../S/661.html#L540'>aIndex</a>            540 router/pns_line.cpp     if( aIndex == 0 )</span>
<span class='curline'><a href='../S/661.html#L542'>aIndex</a>            542 router/pns_line.cpp     else if( aIndex == m_line.SegmentCount() )</span>
<span class='curline'><a href='../S/661.html#L547'>aIndex</a>            547 router/pns_line.cpp         path = dragCornerInternal( m_line.Slice( 0, aIndex ), snapped );</span>
<span class='curline'><a href='../S/661.html#L549'>aIndex</a>            549 router/pns_line.cpp                 dragCornerInternal( m_line.Slice( aIndex, -1 ).Reverse(), snapped ).Reverse();</span>
<span class='curline'><a href='../S/661.html#L557'>aIndex</a>            557 router/pns_line.cpp void LINE::dragCornerFree( const VECTOR2I&amp; aP, int aIndex )</span>
<span class='curline'><a href='../S/661.html#L559'>aIndex</a>            559 router/pns_line.cpp     m_line.SetPoint( aIndex, aP );</span>
<span class='curline'><a href='../S/661.html#L563'>aIndex</a>            563 router/pns_line.cpp void LINE::DragCorner( const VECTOR2I&amp; aP, int aIndex, bool aFreeAngle )</span>
<span class='curline'><a href='../S/661.html#L567'>aIndex</a>            567 router/pns_line.cpp         dragCornerFree( aP, aIndex );</span>
<span class='curline'><a href='../S/661.html#L571'>aIndex</a>            571 router/pns_line.cpp         dragCorner45( aP, aIndex );</span>
<span class='curline'><a href='../S/661.html#L575'>aIndex</a>            575 router/pns_line.cpp void LINE::DragSegment( const VECTOR2I&amp; aP, int aIndex, bool aFreeAngle )</span>
<span class='curline'><a href='../S/661.html#L583'>aIndex</a>            583 router/pns_line.cpp         dragSegment45( aP, aIndex );</span>
<span class='curline'><a href='../S/661.html#L588'>aIndex</a>            588 router/pns_line.cpp         const SHAPE_LINE_CHAIN&amp; aPath, const VECTOR2I&amp; aP, int aIndex ) const</span>
<span class='curline'><a href='../S/661.html#L590'>aIndex</a>            590 router/pns_line.cpp     int s_start = std::max( aIndex - 2, 0 );</span>
<span class='curline'><a href='../S/661.html#L591'>aIndex</a>            591 router/pns_line.cpp     int s_end = std::min( aIndex + 2, aPath.SegmentCount() - 1 );</span>
<span class='curline'><a href='../S/661.html#L630'>aIndex</a>            630 router/pns_line.cpp         const SHAPE_LINE_CHAIN&amp; aPath, const VECTOR2I&amp; aP, int aIndex ) const</span>
<span class='curline'><a href='../S/661.html#L633'>aIndex</a>            633 router/pns_line.cpp     DIRECTION_45 dragDir( aPath.CSegment( aIndex ) );</span>
<span class='curline'><a href='../S/661.html#L639'>aIndex</a>            639 router/pns_line.cpp     if( aIndex &gt;= 2 )</span>
<span class='curline'><a href='../S/661.html#L641'>aIndex</a>            641 router/pns_line.cpp         SEG s = aPath.CSegment( aIndex - 2 );</span>
<span class='curline'><a href='../S/661.html#L649'>aIndex</a>            649 router/pns_line.cpp     if( aIndex &lt; aPath.SegmentCount() - 2 )</span>
<span class='curline'><a href='../S/661.html#L651'>aIndex</a>            651 router/pns_line.cpp         SEG s = aPath.CSegment( aIndex + 2 );</span>
<span class='curline'><a href='../S/661.html#L674'>aIndex</a>            674 router/pns_line.cpp void LINE::dragSegment45( const VECTOR2I&amp; aP, int aIndex )</span>
<span class='curline'><a href='../S/661.html#L680'>aIndex</a>            680 router/pns_line.cpp     int index = aIndex;</span>
<span class='curline'><a href='../S/661.html#L682'>aIndex</a>            682 router/pns_line.cpp     target = snapToNeighbourSegments( path, aP, aIndex );</span>
<span class='curline'><a href='../S/661.html#L721'>aIndex</a>            721 router/pns_line.cpp     if( aIndex == 0 )</span>
<span class='curline'><a href='../S/661.html#L738'>aIndex</a>            738 router/pns_line.cpp     if( aIndex == m_line.SegmentCount() - 1 )</span>
<span class='curline'><a href='../S/661.html#L814'>aIndex</a>            814 router/pns_line.cpp     else if( aIndex == 0 )</span>
<span class='curline'><a href='../S/661.html#L816'>aIndex</a>            816 router/pns_line.cpp     else if( aIndex == m_line.SegmentCount() - 1 )</span>
<span class='curline'><a href='../S/661.html#L819'>aIndex</a>            819 router/pns_line.cpp         m_line.Replace( aIndex, aIndex + 1, best );</span>
<span class='curline'><a href='../S/662.html#L245'>aIndex</a>            245 router/pns_line.h     void DragSegment( const VECTOR2I&amp; aP, int aIndex, bool aFreeAngle = false );</span>
<span class='curline'><a href='../S/662.html#L246'>aIndex</a>            246 router/pns_line.h     void DragCorner( const VECTOR2I&amp; aP, int aIndex, bool aFreeAngle = false );</span>
<span class='curline'><a href='../S/662.html#L270'>aIndex</a>            270 router/pns_line.h     void dragSegment45( const VECTOR2I&amp; aP, int aIndex );</span>
<span class='curline'><a href='../S/662.html#L271'>aIndex</a>            271 router/pns_line.h     void dragCorner45( const VECTOR2I&amp; aP, int aIndex );</span>
<span class='curline'><a href='../S/662.html#L272'>aIndex</a>            272 router/pns_line.h     void dragSegmentFree( const VECTOR2I&amp; aP, int aIndex );</span>
<span class='curline'><a href='../S/662.html#L273'>aIndex</a>            273 router/pns_line.h     void dragCornerFree( const VECTOR2I&amp; aP, int aIndex );</span>
<span class='curline'><a href='../S/662.html#L276'>aIndex</a>            276 router/pns_line.h             const SHAPE_LINE_CHAIN&amp; aPath, const VECTOR2I&amp; aP, int aIndex ) const;</span>
<span class='curline'><a href='../S/662.html#L279'>aIndex</a>            279 router/pns_line.h             const SHAPE_LINE_CHAIN&amp; aPath, const VECTOR2I&amp; aP, int aIndex ) const;</span>
<span class='curline'><a href='../S/666.html#L63'>aIndex</a>             63 router/pns_link_holder.h     LINKED_ITEM* GetLink( int aIndex ) const</span>
<span class='curline'><a href='../S/666.html#L65'>aIndex</a>             65 router/pns_link_holder.h         return m_links[aIndex];</span>
<span class='curline'><a href='../S/670.html#L158'>aIndex</a>            158 router/pns_meander.h     void SetBaseIndex( int aIndex )</span>
<span class='curline'><a href='../S/670.html#L160'>aIndex</a>            160 router/pns_meander.h         m_baseIndex = aIndex;</span>
<span class='curline'><a href='../S/687.html#L104'>aIndex</a>            104 router/pns_shove.cpp LINE SHOVE::assembleLine( const LINKED_ITEM* aSeg, int* aIndex )</span>
<span class='curline'><a href='../S/687.html#L106'>aIndex</a>            106 router/pns_shove.cpp     return m_currentNode-&gt;AssembleLine( const_cast&lt;LINKED_ITEM*&gt;( aSeg ), aIndex, true );</span>
<span class='curline'><a href='../S/688.html#L145'>aIndex</a>            145 router/pns_shove.h     LINE assembleLine( const LINKED_ITEM* aSeg, int* aIndex = NULL );</span>
<span class='curline'><a href='../S/715.html#L326'>aIndex</a>            326 specctra_import_export/specctra.h     ELEM*   Replace( int aIndex, ELEM* aElem )</span>
<span class='curline'><a href='../S/715.html#L328'>aIndex</a>            328 specctra_import_export/specctra.h         ELEM_ARRAY::auto_type ret = kids.replace( aIndex, aElem );</span>
<span class='curline'><a href='../S/715.html#L332'>aIndex</a>            332 specctra_import_export/specctra.h     ELEM*   Remove( int aIndex )</span>
<span class='curline'><a href='../S/715.html#L334'>aIndex</a>            334 specctra_import_export/specctra.h         ELEM_ARRAY::auto_type ret = kids.release( kids.begin()+aIndex );</span>
<span class='curline'><a href='../S/715.html#L338'>aIndex</a>            338 specctra_import_export/specctra.h     void    Insert( int aIndex, ELEM* aElem )</span>
<span class='curline'><a href='../S/715.html#L340'>aIndex</a>            340 specctra_import_export/specctra.h         kids.insert( kids.begin()+aIndex, aElem );</span>
<span class='curline'><a href='../S/715.html#L343'>aIndex</a>            343 specctra_import_export/specctra.h     ELEM*   At( int aIndex ) const</span>
<span class='curline'><a href='../S/715.html#L347'>aIndex</a>            347 specctra_import_export/specctra.h         return (ELEM*) &amp;kids[aIndex];</span>
<span class='curline'><a href='../S/715.html#L350'>aIndex</a>            350 specctra_import_export/specctra.h     ELEM* operator[]( int aIndex ) const</span>
<span class='curline'><a href='../S/715.html#L352'>aIndex</a>            352 specctra_import_export/specctra.h         return At( aIndex );</span>
<span class='curline'><a href='../S/715.html#L355'>aIndex</a>            355 specctra_import_export/specctra.h     void    Delete( int aIndex )</span>
<span class='curline'><a href='../S/715.html#L357'>aIndex</a>            357 specctra_import_export/specctra.h         kids.erase( kids.begin()+aIndex );</span>
</pre>
</body>
</html>
