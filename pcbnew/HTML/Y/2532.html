<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>M_PI</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/60.html#L280'>M_PI</a>              280 class_dimension.cpp     int dx = KiROUND( m_Height * cos( angle + M_PI / 2 ) );</span>
<span class='curline'><a href='../S/60.html#L281'>M_PI</a>              281 class_dimension.cpp     int dy = KiROUND( m_Height * sin( angle + M_PI / 2 ) );</span>
<span class='curline'><a href='../S/69.html#L223'>M_PI</a>              223 class_module.h     double GetOrientationRadians() const { return m_Orient * M_PI / 1800; }</span>
<span class='curline'><a href='../S/71.html#L326'>M_PI</a>              326 class_pad.h        double GetOrientationRadians() const   { return m_Orient*M_PI/1800; }</span>
<span class='curline'><a href='../S/77.html#L185'>M_PI</a>              185 class_text_mod.h     double GetDrawRotationRadians() const { return GetDrawRotation() * M_PI/1800; }</span>
<span class='curline'><a href='../S/79.html#L334'>M_PI</a>              334 class_track.h          return radius * M_PI * angle / 180.0;</span>
<span class='curline'><a href='../S/419.html#L617'>M_PI</a>              617 exporters/export_vrml.cpp     double  angle   = atan2( endy - starty, endx - startx ) * 180.0 / M_PI;</span>
<span class='curline'><a href='../S/476.html#L377'>M_PI</a>              377 import_gfx/dxf_import_plugin.cpp     startPoint = startPoint.Rotate( startangle * M_PI / 180.0 );</span>
<span class='curline'><a href='../S/476.html#L503'>M_PI</a>              503 import_gfx/dxf_import_plugin.cpp     double angle_degree = aData.angle * 180 / M_PI;</span>
<span class='curline'><a href='../S/476.html#L506'>M_PI</a>              506 import_gfx/dxf_import_plugin.cpp     double angleInRads = angle_degree * M_PI / 180.0;</span>
<span class='curline'><a href='../S/476.html#L663'>M_PI</a>              663 import_gfx/dxf_import_plugin.cpp     double angle_degree = aData.angle * 180/M_PI;</span>
<span class='curline'><a href='../S/476.html#L666'>M_PI</a>              666 import_gfx/dxf_import_plugin.cpp     double angleInRads = angle_degree * M_PI / 180.0;</span>
<span class='curline'><a href='../S/476.html#L982'>M_PI</a>              982 import_gfx/dxf_import_plugin.cpp     if( ang &lt; -M_PI )</span>
<span class='curline'><a href='../S/476.html#L983'>M_PI</a>              983 import_gfx/dxf_import_plugin.cpp         offAng += M_PI;</span>
<span class='curline'><a href='../S/476.html#L984'>M_PI</a>              984 import_gfx/dxf_import_plugin.cpp     else if( ang &gt; M_PI )</span>
<span class='curline'><a href='../S/476.html#L985'>M_PI</a>              985 import_gfx/dxf_import_plugin.cpp         offAng -= M_PI;</span>
<span class='curline'><a href='../S/507.html#L60'>M_PI</a>               60 microwave/microwave_inductor.cpp     double increment_angle = (double) a_ArcAngle * M_PI / 1800 / seg_count;</span>
<span class='curline'><a href='../S/507.html#L186'>M_PI</a>              186 microwave/microwave_inductor.cpp         full_len += KiROUND( ( segm_count + 2 ) * M_PI * ADJUST_SIZE * radius );    // Ard arcs len</span>
<span class='curline'><a href='../S/507.html#L205'>M_PI</a>              205 microwave/microwave_inductor.cpp         const int min_total_length = 2 * stubs_len + 2 * M_PI * ADJUST_SIZE * radius;</span>
<span class='curline'><a href='../S/593.html#L470'>M_PI</a>              470 pcb_painter.cpp                 textOrientation = M_PI / 2;</span>
<span class='curline'><a href='../S/593.html#L664'>M_PI</a>              664 pcb_painter.cpp             m_gal-&gt;DrawArc( center, radius, 0.0, M_PI / 2.0 );</span>
<span class='curline'><a href='../S/593.html#L667'>M_PI</a>              667 pcb_painter.cpp             m_gal-&gt;DrawArc( center, radius, M_PI, 3.0 * M_PI / 2.0 );</span>
<span class='curline'><a href='../S/593.html#L671'>M_PI</a>              671 pcb_painter.cpp             m_gal-&gt;DrawArc( center, radius, M_PI / 2.0, M_PI );</span>
<span class='curline'><a href='../S/593.html#L672'>M_PI</a>              672 pcb_painter.cpp             m_gal-&gt;DrawArc( center, radius, 3.0 * M_PI / 2.0, 2.0 * M_PI );</span>
<span class='curline'><a href='../S/593.html#L1253'>M_PI</a>             1253 pcb_painter.cpp         m_gal-&gt;Rotate( M_PI / 4.0 );</span>
<span class='curline'><a href='../S/661.html#L414'>M_PI</a>              414 router/pns_line.cpp         double angle = 180.0 / M_PI *</span>
<span class='curline'><a href='../S/669.html#L213'>M_PI</a>              213 router/pns_meander.cpp         double angleStep = M_PI / 2.0 / (double) ArcSegments;</span>
<span class='curline'><a href='../S/669.html#L229'>M_PI</a>              229 router/pns_meander.cpp             double alpha = (double) i / (double) ( ArcSegments - 1 ) * M_PI / 2.0;</span>
<span class='curline'><a href='../S/669.html#L240'>M_PI</a>              240 router/pns_meander.cpp             correction = (double)(-2 * abs(m_baselineOffset)) * tan( 22.5 * M_PI / 180.0 );</span>
<span class='curline'><a href='../S/669.html#L298'>M_PI</a>              298 router/pns_meander.cpp     m_currentDir = m_currentDir.Rotate( (double) aAngle * M_PI / 180.0 );</span>
<span class='curline'><a href='../S/669.html#L314'>M_PI</a>              314 router/pns_meander.cpp     m_currentDir = dir.Rotate( aSide ? -M_PI / 2.0 : M_PI / 2.0 );</span>
<span class='curline'><a href='../S/679.html#L698'>M_PI</a>              698 router/pns_optimizer.cpp         l.Append( p0 + v0.Rotate( angle * M_PI / 180.0 ) );</span>
<span class='curline'><a href='../S/679.html#L720'>M_PI</a>              720 router/pns_optimizer.cpp         VECTOR2I v0( p0 + VECTOR2I( length, 0 ).Rotate( angle * M_PI / 180.0 ) );</span>
<span class='curline'><a href='../S/717.html#L479'>M_PI</a>              479 specctra_import_export/specctra_export.cpp             double correctionFactor = cos( M_PI / (double) circleToSegmentsCount );</span>
<span class='curline'><a href='../S/717.html#L752'>M_PI</a>              752 specctra_import_export/specctra_export.cpp                     double radians =  2*M_PI / seg_per_circle * ii;</span>
<span class='curline'><a href='../S/763.html#L717'>M_PI</a>              717 tools/drawing_tool.cpp                 double angle = dimension-&gt;GetAngle() + ( M_PI / 2 );</span>
<span class='curline'><a href='../S/822.html#L1062'>M_PI</a>             1062 zone_filler.cpp         filledPolys.Rotate( M_PI/180.0 * orientation, VECTOR2I( 0,0 ) );</span>
<span class='curline'><a href='../S/822.html#L1171'>M_PI</a>             1171 zone_filler.cpp         holes.Rotate( -M_PI/180.0 * orientation, VECTOR2I( 0,0 ) );</span>
</pre>
</body>
</html>
