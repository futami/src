<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>ITEM</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/638.html#L68'>ITEM</a>               68 router/pns_arc.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/639.html#L55'>ITEM</a>               55 router/pns_component_dragger.cpp         if( item.item-&gt;Kind() != ITEM::SOLID_T )</span>
<span class='curline'><a href='../S/639.html#L65'>ITEM</a>               65 router/pns_component_dragger.cpp             if( link.item-&gt;OfKind( ITEM::SEGMENT_T | ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/642.html#L44'>ITEM</a>               44 router/pns_diff_pair.cpp DP_PRIMITIVE_PAIR::DP_PRIMITIVE_PAIR( ITEM* aPrimP, ITEM* aPrimN )</span>
<span class='curline'><a href='../S/642.html#L110'>ITEM</a>              110 router/pns_diff_pair.cpp     return m_primP-&gt;OfKind( ITEM::SEGMENT_T );</span>
<span class='curline'><a href='../S/642.html#L114'>ITEM</a>              114 router/pns_diff_pair.cpp DIRECTION_45 DP_PRIMITIVE_PAIR::anchorDirection( const ITEM* aItem, const VECTOR2I&amp; aP ) const</span>
<span class='curline'><a href='../S/642.html#L116'>ITEM</a>              116 router/pns_diff_pair.cpp     if( !aItem-&gt;OfKind ( ITEM::SEGMENT_T | ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/642.html#L131'>ITEM</a>              131 router/pns_diff_pair.cpp     if ( m_primP-&gt;OfKind( ITEM::SEGMENT_T ) &amp;&amp; m_primN-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/642.html#L440'>ITEM</a>              440 router/pns_diff_pair.cpp     const int pvMask = ITEM::SOLID_T | ITEM::VIA_T;</span>
<span class='curline'><a href='../S/642.html#L449'>ITEM</a>              449 router/pns_diff_pair.cpp     else if( aPair.PrimP()-&gt;OfKind( ITEM::SEGMENT_T ) &amp;&amp; aPair.PrimN()-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/643.html#L144'>ITEM</a>              144 router/pns_diff_pair.h     DP_PRIMITIVE_PAIR( ITEM* aPrimP, ITEM* aPrimN );</span>
<span class='curline'><a href='../S/643.html#L156'>ITEM</a>              156 router/pns_diff_pair.h     ITEM* PrimP() const { return m_primP; }</span>
<span class='curline'><a href='../S/643.html#L157'>ITEM</a>              157 router/pns_diff_pair.h     ITEM* PrimN() const { return m_primN; }</span>
<span class='curline'><a href='../S/643.html#L174'>ITEM</a>              174 router/pns_diff_pair.h     DIRECTION_45 anchorDirection( const ITEM* aItem, const VECTOR2I&amp; aP ) const;</span>
<span class='curline'><a href='../S/643.html#L176'>ITEM</a>              176 router/pns_diff_pair.h     ITEM* m_primP;</span>
<span class='curline'><a href='../S/643.html#L177'>ITEM</a>              177 router/pns_diff_pair.h     ITEM* m_primN;</span>
<span class='curline'><a href='../S/643.html#L290'>ITEM</a>              290 router/pns_diff_pair.h     DIFF_PAIR() : LINK_HOLDER( ITEM::DIFF_PAIR_T ), m_hasVias( false )</span>
<span class='curline'><a href='../S/643.html#L303'>ITEM</a>              303 router/pns_diff_pair.h         LINK_HOLDER( ITEM::DIFF_PAIR_T ),</span>
<span class='curline'><a href='../S/643.html#L319'>ITEM</a>              319 router/pns_diff_pair.h         LINK_HOLDER( ITEM::DIFF_PAIR_T ),</span>
<span class='curline'><a href='../S/643.html#L337'>ITEM</a>              337 router/pns_diff_pair.h         LINK_HOLDER( ITEM::DIFF_PAIR_T ),</span>
<span class='curline'><a href='../S/643.html#L356'>ITEM</a>              356 router/pns_diff_pair.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/643.html#L358'>ITEM</a>              358 router/pns_diff_pair.h         return aItem &amp;&amp; ITEM::DIFF_PAIR_T == aItem-&gt;Kind();</span>
<span class='curline'><a href='../S/644.html#L181'>ITEM</a>              181 router/pns_diff_pair_placer.cpp     int mask = aSolidsOnly ? ITEM::SOLID_T : ITEM::ANY_T;</span>
<span class='curline'><a href='../S/644.html#L392'>ITEM</a>              392 router/pns_diff_pair_placer.cpp     else if( !m_prevPair-&gt;PrimP() || ( m_prevPair-&gt;PrimP()-&gt;OfKind( ITEM::VIA_T ) &amp;&amp;</span>
<span class='curline'><a href='../S/644.html#L406'>ITEM</a>              406 router/pns_diff_pair_placer.cpp OPT_VECTOR2I DIFF_PAIR_PLACER::getDanglingAnchor( NODE* aNode, ITEM* aItem )</span>
<span class='curline'><a href='../S/644.html#L410'>ITEM</a>              410 router/pns_diff_pair_placer.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/644.html#L411'>ITEM</a>              411 router/pns_diff_pair_placer.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/644.html#L414'>ITEM</a>              414 router/pns_diff_pair_placer.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/644.html#L415'>ITEM</a>              415 router/pns_diff_pair_placer.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/644.html#L438'>ITEM</a>              438 router/pns_diff_pair_placer.cpp bool DIFF_PAIR_PLACER::findDpPrimitivePair( const VECTOR2I&amp; aP, ITEM* aItem,</span>
<span class='curline'><a href='../S/644.html#L464'>ITEM</a>              464 router/pns_diff_pair_placer.cpp     ITEM* primRef = aItem;</span>
<span class='curline'><a href='../S/644.html#L479'>ITEM</a>              479 router/pns_diff_pair_placer.cpp     std::set&lt;ITEM*&gt; coupledItems;</span>
<span class='curline'><a href='../S/644.html#L485'>ITEM</a>              485 router/pns_diff_pair_placer.cpp     for( ITEM* item : coupledItems )</span>
<span class='curline'><a href='../S/644.html#L497'>ITEM</a>              497 router/pns_diff_pair_placer.cpp             if( item-&gt;OfKind( ITEM::SOLID_T ) &amp;&amp; item-&gt;Layers() != aItem-&gt;Layers() )</span>
<span class='curline'><a href='../S/644.html#L548'>ITEM</a>              548 router/pns_diff_pair_placer.cpp bool DIFF_PAIR_PLACER::Start( const VECTOR2I&amp; aP, ITEM* aStartItem )</span>
<span class='curline'><a href='../S/644.html#L713'>ITEM</a>              713 router/pns_diff_pair_placer.cpp bool DIFF_PAIR_PLACER::Move( const VECTOR2I&amp; aP , ITEM* aEndItem )</span>
<span class='curline'><a href='../S/644.html#L747'>ITEM</a>              747 router/pns_diff_pair_placer.cpp bool DIFF_PAIR_PLACER::FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish )</span>
<span class='curline'><a href='../S/645.html#L67'>ITEM</a>               67 router/pns_diff_pair_placer.h     bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) override;</span>
<span class='curline'><a href='../S/645.html#L76'>ITEM</a>               76 router/pns_diff_pair_placer.h     bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) override;</span>
<span class='curline'><a href='../S/645.html#L87'>ITEM</a>               87 router/pns_diff_pair_placer.h     bool FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish ) override;</span>
<span class='curline'><a href='../S/645.html#L238'>ITEM</a>              238 router/pns_diff_pair_placer.h     bool findDpPrimitivePair( const VECTOR2I&amp; aP, ITEM* aItem, DP_PRIMITIVE_PAIR&amp; aPair, wxString* aErrorMsg = nullptr );</span>
<span class='curline'><a href='../S/645.html#L239'>ITEM</a>              239 router/pns_diff_pair_placer.h     OPT_VECTOR2I getDanglingAnchor( NODE* aNode, ITEM* aItem );</span>
<span class='curline'><a href='../S/645.html#L303'>ITEM</a>              303 router/pns_diff_pair_placer.h     ITEM* m_currentEndItem;</span>
<span class='curline'><a href='../S/646.html#L72'>ITEM</a>               72 router/pns_dp_meander_placer.cpp bool DP_MEANDER_PLACER::Start( const VECTOR2I&amp; aP, ITEM* aStartItem )</span>
<span class='curline'><a href='../S/646.html#L76'>ITEM</a>               76 router/pns_dp_meander_placer.cpp     if( !aStartItem || !aStartItem-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/646.html#L134'>ITEM</a>              134 router/pns_dp_meander_placer.cpp     for( const ITEM* item : m_tunedPathP.CItems() )</span>
<span class='curline'><a href='../S/646.html#L141'>ITEM</a>              141 router/pns_dp_meander_placer.cpp     for( const ITEM* item : m_tunedPathN.CItems() )</span>
<span class='curline'><a href='../S/646.html#L170'>ITEM</a>              170 router/pns_dp_meander_placer.cpp bool DP_MEANDER_PLACER::Move( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/646.html#L212'>ITEM</a>              212 router/pns_dp_meander_placer.cpp     for( const ITEM* item : m_tunedPathP.CItems() )</span>
<span class='curline'><a href='../S/646.html#L218'>ITEM</a>              218 router/pns_dp_meander_placer.cpp     for( const ITEM* item : m_tunedPathN.CItems() )</span>
<span class='curline'><a href='../S/646.html#L310'>ITEM</a>              310 router/pns_dp_meander_placer.cpp bool DP_MEANDER_PLACER::FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish )</span>
<span class='curline'><a href='../S/647.html#L61'>ITEM</a>               61 router/pns_dp_meander_placer.h     bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) override;</span>
<span class='curline'><a href='../S/647.html#L70'>ITEM</a>               70 router/pns_dp_meander_placer.h     bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) override;</span>
<span class='curline'><a href='../S/647.html#L81'>ITEM</a>               81 router/pns_dp_meander_placer.h     bool FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish = false ) override;</span>
<span class='curline'><a href='../S/648.html#L121'>ITEM</a>              121 router/pns_dragger.cpp     for( ITEM* item : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/648.html#L123'>ITEM</a>              123 router/pns_dragger.cpp         if( item-&gt;OfKind( ITEM::SEGMENT_T | ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/648.html#L133'>ITEM</a>              133 router/pns_dragger.cpp         } else if ( item-&gt;OfKind( ITEM::VIA_T )) </span>
<span class='curline'><a href='../S/648.html#L147'>ITEM</a>              147 router/pns_dragger.cpp     ITEM* startItem = aPrimitives[0];</span>
<span class='curline'><a href='../S/648.html#L167'>ITEM</a>              167 router/pns_dragger.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/648.html#L170'>ITEM</a>              170 router/pns_dragger.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/648.html#L173'>ITEM</a>              173 router/pns_dragger.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/648.html#L253'>ITEM</a>              253 router/pns_dragger.cpp     for( ITEM* item : fanout.Items() )</span>
<span class='curline'><a href='../S/648.html#L293'>ITEM</a>              293 router/pns_dragger.cpp     for( ITEM* item : fanout.Items() )</span>
<span class='curline'><a href='../S/651.html#L38'>ITEM</a>               38 router/pns_index.cpp INDEX::ITEM_SHAPE_INDEX* INDEX::getSubindex( const ITEM* aItem )</span>
<span class='curline'><a href='../S/651.html#L46'>ITEM</a>               46 router/pns_index.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/651.html#L50'>ITEM</a>               50 router/pns_index.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/651.html#L63'>ITEM</a>               63 router/pns_index.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/651.html#L64'>ITEM</a>               64 router/pns_index.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/651.html#L65'>ITEM</a>               65 router/pns_index.cpp     case ITEM::LINE_T:</span>
<span class='curline'><a href='../S/651.html#L86'>ITEM</a>               86 router/pns_index.cpp void INDEX::Add( ITEM* aItem )</span>
<span class='curline'><a href='../S/651.html#L103'>ITEM</a>              103 router/pns_index.cpp void INDEX::Remove( ITEM* aItem )</span>
<span class='curline'><a href='../S/651.html#L118'>ITEM</a>              118 router/pns_index.cpp void INDEX::Replace( ITEM* aOldItem, ITEM* aNewItem )</span>
<span class='curline'><a href='../S/652.html#L49'>ITEM</a>               49 router/pns_index.h     typedef std::list&lt;ITEM*&gt;            NET_ITEMS_LIST;</span>
<span class='curline'><a href='../S/652.html#L50'>ITEM</a>               50 router/pns_index.h     typedef SHAPE_INDEX&lt;ITEM*&gt;          ITEM_SHAPE_INDEX;</span>
<span class='curline'><a href='../S/652.html#L51'>ITEM</a>               51 router/pns_index.h     typedef std::unordered_set&lt;ITEM*&gt;   ITEM_SET;</span>
<span class='curline'><a href='../S/652.html#L61'>ITEM</a>               61 router/pns_index.h     void Add( ITEM* aItem );</span>
<span class='curline'><a href='../S/652.html#L68'>ITEM</a>               68 router/pns_index.h     void Remove( ITEM* aItem );</span>
<span class='curline'><a href='../S/652.html#L75'>ITEM</a>               75 router/pns_index.h     void Replace( ITEM* aOldItem, ITEM* aNewItem );</span>
<span class='curline'><a href='../S/652.html#L91'>ITEM</a>               91 router/pns_index.h     int Query( const ITEM* aItem, int aMinDistance, Visitor&amp; aVisitor );</span>
<span class='curline'><a href='../S/652.html#L128'>ITEM</a>              128 router/pns_index.h     bool Contains( ITEM* aItem ) const</span>
<span class='curline'><a href='../S/652.html#L155'>ITEM</a>              155 router/pns_index.h     ITEM_SHAPE_INDEX* getSubindex( const ITEM* aItem );</span>
<span class='curline'><a href='../S/652.html#L173'>ITEM</a>              173 router/pns_index.h int INDEX::Query( const ITEM* aItem, int aMinDistance, Visitor&amp; aVisitor )</span>
<span class='curline'><a href='../S/653.html#L30'>ITEM</a>               30 router/pns_item.cpp bool ITEM::collideSimple( const ITEM* aOther, int aClearance, bool aNeedMTV, VECTOR2I* aMTV,</span>
<span class='curline'><a href='../S/653.html#L48'>ITEM</a>               48 router/pns_item.cpp bool ITEM::Collide( const ITEM* aOther, int aClearance, bool aNeedMTV, VECTOR2I* aMTV,</span>
<span class='curline'><a href='../S/653.html#L71'>ITEM</a>               71 router/pns_item.cpp std::string ITEM::KindStr() const</span>
<span class='curline'><a href='../S/653.html#L87'>ITEM</a>               87 router/pns_item.cpp ITEM::~ITEM()</span>
<span class='curline'><a href='../S/654.html#L53'>ITEM</a>               53 router/pns_item.h class ITEM</span>
<span class='curline'><a href='../S/654.html#L71'>ITEM</a>               71 router/pns_item.h     ITEM( PnsKind aKind )</span>
<span class='curline'><a href='../S/654.html#L83'>ITEM</a>               83 router/pns_item.h     ITEM( const ITEM&amp; aOther )</span>
<span class='curline'><a href='../S/654.html#L96'>ITEM</a>               96 router/pns_item.h     virtual ~ITEM();</span>
<span class='curline'><a href='../S/654.html#L103'>ITEM</a>              103 router/pns_item.h     virtual ITEM* Clone() const = 0;</span>
<span class='curline'><a href='../S/654.html#L163'>ITEM</a>              163 router/pns_item.h     bool LayersOverlap( const ITEM* aOther ) const</span>
<span class='curline'><a href='../S/654.html#L205'>ITEM</a>              205 router/pns_item.h     virtual bool Collide( const ITEM* aOther, int aClearance, bool aNeedMTV, VECTOR2I* aMTV,</span>
<span class='curline'><a href='../S/654.html#L245'>ITEM</a>              245 router/pns_item.h     bool collideSimple( const ITEM* aOther, int aClearance, bool aNeedMTV, VECTOR2I* aMTV,</span>
<span class='curline'><a href='../S/654.html#L265'>ITEM</a>              265 router/pns_item.h     static_assert(std::is_base_of&lt; ITEM, S &gt;::value, "Need to be handed a ITEM!");</span>
<span class='curline'><a href='../S/654.html#L266'>ITEM</a>              266 router/pns_item.h     static_assert(std::is_base_of&lt; ITEM, T &gt;::value, "Need to cast to an ITEM!");</span>
<span class='curline'><a href='../S/654.html#L273'>ITEM</a>              273 router/pns_item.h     static_assert(std::is_base_of&lt; ITEM, T &gt;::value, "Need to be handed an ITEM!");</span>
<span class='curline'><a href='../S/655.html#L124'>ITEM</a>              124 router/pns_itemset.cpp ITEM_SET&amp; ITEM_SET::ExcludeItem( const ITEM* aItem )</span>
<span class='curline'><a href='../S/656.html#L44'>ITEM</a>               44 router/pns_itemset.h         ENTRY( ITEM* aItem, bool aOwned = false ) :</span>
<span class='curline'><a href='../S/656.html#L87'>ITEM</a>               87 router/pns_itemset.h         operator ITEM* () const</span>
<span class='curline'><a href='../S/656.html#L92'>ITEM</a>               92 router/pns_itemset.h         ITEM *item;</span>
<span class='curline'><a href='../S/656.html#L98'>ITEM</a>               98 router/pns_itemset.h     ITEM_SET( ITEM* aInitialItem = NULL, bool aBecomeOwner = false )</span>
<span class='curline'><a href='../S/656.html#L123'>ITEM</a>              123 router/pns_itemset.h         if( aKindMask == -1 || aKindMask == ITEM::ANY_T )</span>
<span class='curline'><a href='../S/656.html#L126'>ITEM</a>              126 router/pns_itemset.h         for( ITEM* item : m_items )</span>
<span class='curline'><a href='../S/656.html#L163'>ITEM</a>              163 router/pns_itemset.h     ITEM_SET&amp; ExcludeItem( const ITEM* aItem );</span>
<span class='curline'><a href='../S/656.html#L173'>ITEM</a>              173 router/pns_itemset.h     ITEM* operator[] ( int index ) const</span>
<span class='curline'><a href='../S/656.html#L178'>ITEM</a>              178 router/pns_itemset.h     void Add( ITEM* aItem, bool aBecomeOwner = false )</span>
<span class='curline'><a href='../S/656.html#L183'>ITEM</a>              183 router/pns_itemset.h     void Prepend( ITEM* aItem, bool aBecomeOwner = false )</span>
<span class='curline'><a href='../S/656.html#L193'>ITEM</a>              193 router/pns_itemset.h     bool Contains( ITEM* aItem ) const</span>
<span class='curline'><a href='../S/656.html#L199'>ITEM</a>              199 router/pns_itemset.h     void Erase( ITEM* aItem )</span>
<span class='curline'><a href='../S/656.html#L209'>ITEM</a>              209 router/pns_itemset.h     T* FindByKind( ITEM::PnsKind kind, int index = 0 )</span>
<span class='curline'><a href='../S/656.html#L213'>ITEM</a>              213 router/pns_itemset.h         for( const ITEM* item : m_items )</span>
<span class='curline'><a href='../S/657.html#L43'>ITEM</a>               43 router/pns_joint.h class JOINT : public ITEM</span>
<span class='curline'><a href='../S/657.html#L71'>ITEM</a>               71 router/pns_joint.h         ITEM( JOINT_T ), m_locked( false ) {}</span>
<span class='curline'><a href='../S/657.html#L74'>ITEM</a>               74 router/pns_joint.h         ITEM( JOINT_T )</span>
<span class='curline'><a href='../S/657.html#L83'>ITEM</a>               83 router/pns_joint.h         ITEM( JOINT_T )</span>
<span class='curline'><a href='../S/657.html#L93'>ITEM</a>               93 router/pns_joint.h     ITEM* Clone( ) const override</span>
<span class='curline'><a href='../S/657.html#L142'>ITEM</a>              142 router/pns_joint.h     void Link( ITEM* aItem )</span>
<span class='curline'><a href='../S/657.html#L152'>ITEM</a>              152 router/pns_joint.h     bool Unlink( ITEM* aItem )</span>
<span class='curline'><a href='../S/657.html#L160'>ITEM</a>              160 router/pns_joint.h     LINKED_ITEM* NextSegment( ITEM* aCurrent ) const</span>
<span class='curline'><a href='../S/657.html#L170'>ITEM</a>              170 router/pns_joint.h         for( ITEM* item : m_linkedItems.Items() )</span>
<span class='curline'><a href='../S/657.html#L233'>ITEM</a>              233 router/pns_joint.h         for( ITEM* item : aJoint.LinkList() )</span>
<span class='curline'><a href='../S/658.html#L78'>ITEM</a>               78 router/pns_kicad_iface.cpp     virtual bool CollideHoles( const PNS::ITEM* aA, const PNS::ITEM* aB,</span>
<span class='curline'><a href='../S/658.html#L81'>ITEM</a>               81 router/pns_kicad_iface.cpp     virtual int Clearance( const PNS::ITEM* aA, const PNS::ITEM* aB ) const override;</span>
<span class='curline'><a href='../S/658.html#L85'>ITEM</a>               85 router/pns_kicad_iface.cpp     virtual bool DpNetPair( PNS::ITEM* aItem, int&amp; aNetP, int&amp; aNetN ) override;</span>
<span class='curline'><a href='../S/658.html#L97'>ITEM</a>               97 router/pns_kicad_iface.cpp     int holeRadius( const PNS::ITEM* aItem ) const;</span>
<span class='curline'><a href='../S/658.html#L98'>ITEM</a>               98 router/pns_kicad_iface.cpp     int localPadClearance( const PNS::ITEM* aItem ) const;</span>
<span class='curline'><a href='../S/658.html#L174'>ITEM</a>              174 router/pns_kicad_iface.cpp int PNS_PCBNEW_RULE_RESOLVER::holeRadius( const PNS::ITEM* aItem ) const</span>
<span class='curline'><a href='../S/658.html#L176'>ITEM</a>              176 router/pns_kicad_iface.cpp     if( aItem-&gt;Kind() == PNS::ITEM::SOLID_T )</span>
<span class='curline'><a href='../S/658.html#L183'>ITEM</a>              183 router/pns_kicad_iface.cpp     else if( aItem-&gt;Kind() == PNS::ITEM::VIA_T )</span>
<span class='curline'><a href='../S/658.html#L195'>ITEM</a>              195 router/pns_kicad_iface.cpp bool PNS_PCBNEW_RULE_RESOLVER::CollideHoles( const PNS::ITEM* aA, const PNS::ITEM* aB,</span>
<span class='curline'><a href='../S/658.html#L233'>ITEM</a>              233 router/pns_kicad_iface.cpp int PNS_PCBNEW_RULE_RESOLVER::localPadClearance( const PNS::ITEM* aItem ) const</span>
<span class='curline'><a href='../S/658.html#L249'>ITEM</a>              249 router/pns_kicad_iface.cpp int PNS_PCBNEW_RULE_RESOLVER::Clearance( const PNS::ITEM* aA, const PNS::ITEM* aB ) const</span>
<span class='curline'><a href='../S/658.html#L374'>ITEM</a>              374 router/pns_kicad_iface.cpp bool PNS_PCBNEW_RULE_RESOLVER::DpNetPair( PNS::ITEM* aItem, int&amp; aNetP, int&amp; aNetN )</span>
<span class='curline'><a href='../S/658.html#L879'>ITEM</a>              879 router/pns_kicad_iface.cpp bool PNS_KICAD_IFACE::IsItemVisible( const PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1035'>ITEM</a>             1035 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE::DisplayItem( const PNS::ITEM* aItem, int aColor, int aClearance, bool aEdit )</span>
<span class='curline'><a href='../S/658.html#L1078'>ITEM</a>             1078 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE::HideItem( PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1093'>ITEM</a>             1093 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE_BASE::RemoveItem( PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1099'>ITEM</a>             1099 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE::RemoveItem( PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1103'>ITEM</a>             1103 router/pns_kicad_iface.cpp     if ( aItem-&gt;OfKind(PNS::ITEM::SOLID_T) )</span>
<span class='curline'><a href='../S/658.html#L1119'>ITEM</a>             1119 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE_BASE::AddItem( PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1125'>ITEM</a>             1125 router/pns_kicad_iface.cpp void PNS_KICAD_IFACE::AddItem( PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/658.html#L1131'>ITEM</a>             1131 router/pns_kicad_iface.cpp     case PNS::ITEM::ARC_T:</span>
<span class='curline'><a href='../S/658.html#L1142'>ITEM</a>             1142 router/pns_kicad_iface.cpp     case PNS::ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/658.html#L1156'>ITEM</a>             1156 router/pns_kicad_iface.cpp     case PNS::ITEM::VIA_T:</span>
<span class='curline'><a href='../S/658.html#L1171'>ITEM</a>             1171 router/pns_kicad_iface.cpp     case PNS::ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/659.html#L56'>ITEM</a>               56 router/pns_kicad_iface.h     bool IsItemVisible( const PNS::ITEM* aItem ) override { return true; }</span>
<span class='curline'><a href='../S/659.html#L57'>ITEM</a>               57 router/pns_kicad_iface.h     void HideItem( PNS::ITEM* aItem ) override {}</span>
<span class='curline'><a href='../S/659.html#L58'>ITEM</a>               58 router/pns_kicad_iface.h     void DisplayItem( const PNS::ITEM* aItem, int aColor = 0, int aClearance = 0, bool aEdit = false ) override {}</span>
<span class='curline'><a href='../S/659.html#L59'>ITEM</a>               59 router/pns_kicad_iface.h     void AddItem( PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/659.html#L60'>ITEM</a>               60 router/pns_kicad_iface.h     void RemoveItem( PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/659.html#L107'>ITEM</a>              107 router/pns_kicad_iface.h     bool IsItemVisible( const PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/659.html#L108'>ITEM</a>              108 router/pns_kicad_iface.h     void HideItem( PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/659.html#L109'>ITEM</a>              109 router/pns_kicad_iface.h     void DisplayItem( const PNS::ITEM* aItem, int aColor = 0, int aClearance = 0, bool aEdit = false ) override;</span>
<span class='curline'><a href='../S/659.html#L111'>ITEM</a>              111 router/pns_kicad_iface.h     void AddItem( PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/659.html#L112'>ITEM</a>              112 router/pns_kicad_iface.h     void RemoveItem( PNS::ITEM* aItem ) override;</span>
<span class='curline'><a href='../S/662.html#L114'>ITEM</a>              114 router/pns_line.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/663.html#L268'>ITEM</a>              268 router/pns_line_placer.cpp         if( m_currentNode-&gt;CheckColliding( &amp;tmp, ITEM::ANY_T ) )</span>
<span class='curline'><a href='../S/663.html#L650'>ITEM</a>              650 router/pns_line_placer.cpp     optimizer.SetCollisionMask( ITEM::SOLID_T );</span>
<span class='curline'><a href='../S/663.html#L707'>ITEM</a>              707 router/pns_line_placer.cpp         optimizer.SetCollisionMask( ITEM::ANY_T );</span>
<span class='curline'><a href='../S/663.html#L909'>ITEM</a>              909 router/pns_line_placer.cpp bool LINE_PLACER::SplitAdjacentSegments( NODE* aNode, ITEM* aSeg, const VECTOR2I&amp; aP )</span>
<span class='curline'><a href='../S/663.html#L914'>ITEM</a>              914 router/pns_line_placer.cpp     if( !aSeg-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/663.html#L951'>ITEM</a>              951 router/pns_line_placer.cpp     else if( !m_startItem || ( m_startItem-&gt;OfKind( ITEM::VIA_T ) &amp;&amp; m_startItem-&gt;Layers().Overlaps( aLayer ) ) )</span>
<span class='curline'><a href='../S/663.html#L966'>ITEM</a>              966 router/pns_line_placer.cpp bool LINE_PLACER::Start( const VECTOR2I&amp; aP, ITEM* aStartItem )</span>
<span class='curline'><a href='../S/663.html#L1042'>ITEM</a>             1042 router/pns_line_placer.cpp bool LINE_PLACER::Move( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/663.html#L1083'>ITEM</a>             1083 router/pns_line_placer.cpp bool LINE_PLACER::FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish )</span>
<span class='curline'><a href='../S/664.html#L122'>ITEM</a>              122 router/pns_line_placer.h     bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) override;</span>
<span class='curline'><a href='../S/664.html#L131'>ITEM</a>              131 router/pns_line_placer.h     bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) override;</span>
<span class='curline'><a href='../S/664.html#L142'>ITEM</a>              142 router/pns_line_placer.h     bool FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish ) override;</span>
<span class='curline'><a href='../S/664.html#L262'>ITEM</a>              262 router/pns_line_placer.h     bool SplitAdjacentSegments( NODE* aNode, ITEM* aSeg, const VECTOR2I&amp; aP );</span>
<span class='curline'><a href='../S/664.html#L460'>ITEM</a>              460 router/pns_line_placer.h     ITEM* m_startItem;</span>
<span class='curline'><a href='../S/666.html#L30'>ITEM</a>               30 router/pns_link_holder.h class LINK_HOLDER : public ITEM</span>
<span class='curline'><a href='../S/666.html#L35'>ITEM</a>               35 router/pns_link_holder.h     LINK_HOLDER( PnsKind aKind ) : ITEM( aKind )</span>
<span class='curline'><a href='../S/665.html#L29'>ITEM</a>               29 router/pns_linked_item.h class LINKED_ITEM : public ITEM</span>
<span class='curline'><a href='../S/665.html#L33'>ITEM</a>               33 router/pns_linked_item.h     LINKED_ITEM( PnsKind aKind ) : ITEM( aKind )</span>
<span class='curline'><a href='../S/667.html#L73'>ITEM</a>               73 router/pns_logger.cpp void LOGGER::Log( LOGGER::EVENT_TYPE evt, VECTOR2I pos, const ITEM* item )</span>
<span class='curline'><a href='../S/668.html#L37'>ITEM</a>               37 router/pns_logger.h class ITEM;</span>
<span class='curline'><a href='../S/668.html#L54'>ITEM</a>               54 router/pns_logger.h         const ITEM* item;</span>
<span class='curline'><a href='../S/668.html#L62'>ITEM</a>               62 router/pns_logger.h     void Log( EVENT_TYPE evt, VECTOR2I pos, const ITEM* item = nullptr );</span>
<span class='curline'><a href='../S/671.html#L60'>ITEM</a>               60 router/pns_meander_placer.cpp bool MEANDER_PLACER::Start( const VECTOR2I&amp; aP, ITEM* aStartItem )</span>
<span class='curline'><a href='../S/671.html#L64'>ITEM</a>               64 router/pns_meander_placer.cpp     if( !aStartItem || !aStartItem-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/671.html#L97'>ITEM</a>               97 router/pns_meander_placer.cpp     for( const ITEM* item : m_tunedPath.CItems() )</span>
<span class='curline'><a href='../S/671.html#L109'>ITEM</a>              109 router/pns_meander_placer.cpp bool MEANDER_PLACER::Move( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/671.html#L115'>ITEM</a>              115 router/pns_meander_placer.cpp bool MEANDER_PLACER::doMove( const VECTOR2I&amp; aP, ITEM* aEndItem, long long int aTargetLength )</span>
<span class='curline'><a href='../S/671.html#L151'>ITEM</a>              151 router/pns_meander_placer.cpp     for( const ITEM* item : m_tunedPath.CItems() )</span>
<span class='curline'><a href='../S/671.html#L193'>ITEM</a>              193 router/pns_meander_placer.cpp bool MEANDER_PLACER::FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish )</span>
<span class='curline'><a href='../S/672.html#L56'>ITEM</a>               56 router/pns_meander_placer.h     virtual bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) override;</span>
<span class='curline'><a href='../S/672.html#L59'>ITEM</a>               59 router/pns_meander_placer.h     virtual bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) override;</span>
<span class='curline'><a href='../S/672.html#L62'>ITEM</a>               62 router/pns_meander_placer.h     virtual bool FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish = false ) override;</span>
<span class='curline'><a href='../S/672.html#L101'>ITEM</a>              101 router/pns_meander_placer.h     bool doMove( const VECTOR2I&amp; aP, ITEM* aEndItem, long long int aTargetLength );</span>
<span class='curline'><a href='../S/675.html#L49'>ITEM</a>               49 router/pns_meander_skew_placer.cpp bool MEANDER_SKEW_PLACER::Start( const VECTOR2I&amp; aP, ITEM* aStartItem )</span>
<span class='curline'><a href='../S/675.html#L53'>ITEM</a>               53 router/pns_meander_skew_placer.cpp     if( !aStartItem || !aStartItem-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/675.html#L121'>ITEM</a>              121 router/pns_meander_skew_placer.cpp     for( const ITEM* item : aSet.CItems() )</span>
<span class='curline'><a href='../S/675.html#L139'>ITEM</a>              139 router/pns_meander_skew_placer.cpp bool MEANDER_SKEW_PLACER::Move( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/675.html#L141'>ITEM</a>              141 router/pns_meander_skew_placer.cpp     for( const ITEM* item : m_tunedPathP.CItems() )</span>
<span class='curline'><a href='../S/675.html#L147'>ITEM</a>              147 router/pns_meander_skew_placer.cpp     for( const ITEM* item : m_tunedPathN.CItems() )</span>
<span class='curline'><a href='../S/676.html#L46'>ITEM</a>               46 router/pns_meander_skew_placer.h     bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) override;</span>
<span class='curline'><a href='../S/676.html#L49'>ITEM</a>               49 router/pns_meander_skew_placer.h     bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) override;</span>
<span class='curline'><a href='../S/677.html#L85'>ITEM</a>               85 router/pns_node.cpp     for( ITEM* item : *m_index )</span>
<span class='curline'><a href='../S/677.html#L97'>ITEM</a>               97 router/pns_node.cpp int NODE::GetClearance( const ITEM* aA, const ITEM* aB ) const</span>
<span class='curline'><a href='../S/677.html#L126'>ITEM</a>              126 router/pns_node.cpp         for( ITEM* item : *m_index )</span>
<span class='curline'><a href='../S/677.html#L149'>ITEM</a>              149 router/pns_node.cpp OBSTACLE_VISITOR::OBSTACLE_VISITOR( const ITEM* aItem ) :</span>
<span class='curline'><a href='../S/677.html#L165'>ITEM</a>              165 router/pns_node.cpp bool OBSTACLE_VISITOR::visit( ITEM* aCandidate )</span>
<span class='curline'><a href='../S/677.html#L199'>ITEM</a>              199 router/pns_node.cpp     DEFAULT_OBSTACLE_VISITOR( NODE::OBSTACLES&amp; aTab, const ITEM* aItem, int aKindMask, bool aDifferentNetsOnly ) :</span>
<span class='curline'><a href='../S/677.html#L209'>ITEM</a>              209 router/pns_node.cpp         if( aItem &amp;&amp; aItem-&gt;Kind() == ITEM::LINE_T )</span>
<span class='curline'><a href='../S/677.html#L224'>ITEM</a>              224 router/pns_node.cpp     bool operator()( ITEM* aCandidate ) override</span>
<span class='curline'><a href='../S/677.html#L234'>ITEM</a>              234 router/pns_node.cpp         if( aCandidate-&gt;Kind() == ITEM::LINE_T ) // this should never happen.</span>
<span class='curline'><a href='../S/677.html#L262'>ITEM</a>              262 router/pns_node.cpp int NODE::QueryColliding( const ITEM* aItem, OBSTACLE_VISITOR&amp; aVisitor )</span>
<span class='curline'><a href='../S/677.html#L278'>ITEM</a>              278 router/pns_node.cpp int NODE::QueryColliding( const ITEM* aItem, NODE::OBSTACLES&amp; aObstacles, int aKindMask,</span>
<span class='curline'><a href='../S/677.html#L305'>ITEM</a>              305 router/pns_node.cpp                                           const std::set&lt;ITEM*&gt;* aRestrictedSet )</span>
<span class='curline'><a href='../S/677.html#L415'>ITEM</a>              415 router/pns_node.cpp     for( const ITEM* item : aSet.CItems() )</span>
<span class='curline'><a href='../S/677.html#L427'>ITEM</a>              427 router/pns_node.cpp NODE::OPT_OBSTACLE NODE::CheckColliding( const ITEM* aItemA, int aKindMask )</span>
<span class='curline'><a href='../S/677.html#L433'>ITEM</a>              433 router/pns_node.cpp     if( aItemA-&gt;Kind() == ITEM::LINE_T )</span>
<span class='curline'><a href='../S/677.html#L463'>ITEM</a>              463 router/pns_node.cpp bool NODE::CheckColliding( const ITEM* aItemA, const ITEM* aItemB, int aKindMask, int aForceClearance )</span>
<span class='curline'><a href='../S/677.html#L473'>ITEM</a>              473 router/pns_node.cpp     if( aItemA-&gt;Kind() == ITEM::LINE_T )</span>
<span class='curline'><a href='../S/677.html#L475'>ITEM</a>              475 router/pns_node.cpp     if( aItemB-&gt;Kind() == ITEM::LINE_T )</span>
<span class='curline'><a href='../S/677.html#L496'>ITEM</a>              496 router/pns_node.cpp     bool operator()( ITEM* aItem ) override</span>
<span class='curline'><a href='../S/677.html#L528'>ITEM</a>              528 router/pns_node.cpp         for( ITEM* item : items_root.Items() )</span>
<span class='curline'><a href='../S/677.html#L651'>ITEM</a>              651 router/pns_node.cpp void NODE::Add( std::unique_ptr&lt; ITEM &gt; aItem, bool aAllowRedundant )</span>
<span class='curline'><a href='../S/677.html#L655'>ITEM</a>              655 router/pns_node.cpp     case ITEM::SOLID_T:   Add( ItemCast&lt;SOLID&gt;( std::move( aItem ) ) );                    break;</span>
<span class='curline'><a href='../S/677.html#L656'>ITEM</a>              656 router/pns_node.cpp     case ITEM::SEGMENT_T: Add( ItemCast&lt;SEGMENT&gt;( std::move( aItem ) ), aAllowRedundant ); break;</span>
<span class='curline'><a href='../S/677.html#L657'>ITEM</a>              657 router/pns_node.cpp     case ITEM::VIA_T:     Add( ItemCast&lt;VIA&gt;( std::move( aItem ) ) );                      break;</span>
<span class='curline'><a href='../S/677.html#L659'>ITEM</a>              659 router/pns_node.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/677.html#L664'>ITEM</a>              664 router/pns_node.cpp     case ITEM::LINE_T:</span>
<span class='curline'><a href='../S/677.html#L671'>ITEM</a>              671 router/pns_node.cpp void NODE::doRemove( ITEM* aItem )</span>
<span class='curline'><a href='../S/677.html#L706'>ITEM</a>              706 router/pns_node.cpp void NODE::rebuildJoint( JOINT* aJoint, ITEM* aItem )</span>
<span class='curline'><a href='../S/677.html#L741'>ITEM</a>              741 router/pns_node.cpp     for(ITEM* link : links)</span>
<span class='curline'><a href='../S/677.html#L766'>ITEM</a>              766 router/pns_node.cpp void NODE::Replace( ITEM* aOldItem, std::unique_ptr&lt; ITEM &gt; aNewItem )</span>
<span class='curline'><a href='../S/677.html#L802'>ITEM</a>              802 router/pns_node.cpp void NODE::Remove( ITEM* aItem )</span>
<span class='curline'><a href='../S/677.html#L806'>ITEM</a>              806 router/pns_node.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/677.html#L810'>ITEM</a>              810 router/pns_node.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/677.html#L814'>ITEM</a>              814 router/pns_node.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/677.html#L818'>ITEM</a>              818 router/pns_node.cpp     case ITEM::LINE_T:</span>
<span class='curline'><a href='../S/677.html#L828'>ITEM</a>              828 router/pns_node.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/677.html#L845'>ITEM</a>              845 router/pns_node.cpp         if( li-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/677.html#L847'>ITEM</a>              847 router/pns_node.cpp         else if( li-&gt;OfKind( ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/677.html#L969'>ITEM</a>              969 router/pns_node.cpp         for( ITEM* item : current-&gt;LinkList() )</span>
<span class='curline'><a href='../S/677.html#L971'>ITEM</a>              971 router/pns_node.cpp             if( item-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/677.html#L995'>ITEM</a>              995 router/pns_node.cpp     for( ITEM* item : aA.LinkList() )</span>
<span class='curline'><a href='../S/677.html#L997'>ITEM</a>              997 router/pns_node.cpp         if( item-&gt;Kind() == ITEM::SEGMENT_T )</span>
<span class='curline'><a href='../S/677.html#L1057'>ITEM</a>             1057 router/pns_node.cpp void NODE::LockJoint( const VECTOR2I&amp; aPos, const ITEM* aItem, bool aLock )</span>
<span class='curline'><a href='../S/677.html#L1123'>ITEM</a>             1123 router/pns_node.cpp                           int aNet, ITEM* aWhere )</span>
<span class='curline'><a href='../S/677.html#L1132'>ITEM</a>             1132 router/pns_node.cpp                             int aNet, ITEM* aWhere )</span>
<span class='curline'><a href='../S/677.html#L1145'>ITEM</a>             1145 router/pns_node.cpp     SHAPE_INDEX_LIST&lt;ITEM*&gt;::iterator i;</span>
<span class='curline'><a href='../S/677.html#L1149'>ITEM</a>             1149 router/pns_node.cpp         if( (*i)-&gt;GetKind() == ITEM::SEGMENT_T )</span>
<span class='curline'><a href='../S/677.html#L1157'>ITEM</a>             1157 router/pns_node.cpp             if( (*i)-&gt;GetKind() == ITEM::SEGMENT_T &amp;&amp; !overrides( *i ) )</span>
<span class='curline'><a href='../S/677.html#L1173'>ITEM</a>             1173 router/pns_node.cpp                 const ITEM* m_item = *k;</span>
<span class='curline'><a href='../S/677.html#L1177'>ITEM</a>             1177 router/pns_node.cpp                 case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/677.html#L1233'>ITEM</a>             1233 router/pns_node.cpp     for( ITEM* item : m_override )</span>
<span class='curline'><a href='../S/677.html#L1258'>ITEM</a>             1258 router/pns_node.cpp     for( ITEM* item : m_garbageItems )</span>
<span class='curline'><a href='../S/677.html#L1273'>ITEM</a>             1273 router/pns_node.cpp         for( ITEM* item : aNode-&gt;m_override )</span>
<span class='curline'><a href='../S/677.html#L1280'>ITEM</a>             1280 router/pns_node.cpp             Add( std::unique_ptr&lt;ITEM&gt;( i ) );</span>
<span class='curline'><a href='../S/677.html#L1294'>ITEM</a>             1294 router/pns_node.cpp void NODE::AllItemsInNet( int aNet, std::set&lt;ITEM*&gt;&amp; aItems )</span>
<span class='curline'><a href='../S/677.html#L1300'>ITEM</a>             1300 router/pns_node.cpp         for( ITEM*item : *l_cur )</span>
<span class='curline'><a href='../S/677.html#L1328'>ITEM</a>             1328 router/pns_node.cpp     std::list&lt;ITEM*&gt; garbage;</span>
<span class='curline'><a href='../S/677.html#L1330'>ITEM</a>             1330 router/pns_node.cpp     for( ITEM* item : *m_index )</span>
<span class='curline'><a href='../S/677.html#L1336'>ITEM</a>             1336 router/pns_node.cpp     for( ITEM* item : garbage )</span>
<span class='curline'><a href='../S/677.html#L1348'>ITEM</a>             1348 router/pns_node.cpp     for( ITEM* item : jtStart-&gt;LinkList() )</span>
<span class='curline'><a href='../S/677.html#L1350'>ITEM</a>             1350 router/pns_node.cpp         if( item-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/677.html#L1379'>ITEM</a>             1379 router/pns_node.cpp     for( ITEM* item : jtStart-&gt;LinkList() )</span>
<span class='curline'><a href='../S/677.html#L1381'>ITEM</a>             1381 router/pns_node.cpp         if( item-&gt;OfKind( ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/677.html#L1443'>ITEM</a>             1443 router/pns_node.cpp ITEM *NODE::FindItemByParent( const BOARD_CONNECTED_ITEM* aParent )</span>
<span class='curline'><a href='../S/677.html#L1449'>ITEM</a>             1449 router/pns_node.cpp         for( ITEM* item : *l_cur )</span>
<span class='curline'><a href='../S/678.html#L62'>ITEM</a>               62 router/pns_node.h     virtual bool CollideHoles( const ITEM* aA, const ITEM* aB,</span>
<span class='curline'><a href='../S/678.html#L65'>ITEM</a>               65 router/pns_node.h     virtual int Clearance( const ITEM* aA, const ITEM* aB ) const = 0;</span>
<span class='curline'><a href='../S/678.html#L69'>ITEM</a>               69 router/pns_node.h     virtual bool DpNetPair( ITEM* aItem, int&amp; aNetP, int&amp; aNetN ) = 0;</span>
<span class='curline'><a href='../S/678.html#L83'>ITEM</a>               83 router/pns_node.h     const ITEM* m_head;</span>
<span class='curline'><a href='../S/678.html#L86'>ITEM</a>               86 router/pns_node.h     ITEM* m_item;</span>
<span class='curline'><a href='../S/678.html#L106'>ITEM</a>              106 router/pns_node.h     OBSTACLE_VISITOR( const ITEM* aItem );</span>
<span class='curline'><a href='../S/678.html#L114'>ITEM</a>              114 router/pns_node.h     virtual bool operator()( ITEM* aCandidate ) = 0;</span>
<span class='curline'><a href='../S/678.html#L118'>ITEM</a>              118 router/pns_node.h     bool visit( ITEM* aCandidate );</span>
<span class='curline'><a href='../S/678.html#L121'>ITEM</a>              121 router/pns_node.h     const ITEM* m_item;</span>
<span class='curline'><a href='../S/678.html#L149'>ITEM</a>              149 router/pns_node.h     typedef std::vector&lt;ITEM*&gt;          ITEM_VECTOR;</span>
<span class='curline'><a href='../S/678.html#L156'>ITEM</a>              156 router/pns_node.h     int GetClearance( const ITEM* aA, const ITEM* aB ) const;</span>
<span class='curline'><a href='../S/678.html#L203'>ITEM</a>              203 router/pns_node.h     int QueryColliding( const ITEM*  aItem,</span>
<span class='curline'><a href='../S/678.html#L205'>ITEM</a>              205 router/pns_node.h                         int          aKindMask = ITEM::ANY_T,</span>
<span class='curline'><a href='../S/678.html#L210'>ITEM</a>              210 router/pns_node.h     int QueryJoints( const BOX2I&amp; aBox, std::vector&lt;JOINT*&gt; &amp; aJoints, int aLayerMask = -1, int aKindMask = ITEM::ANY_T);</span>
<span class='curline'><a href='../S/678.html#L212'>ITEM</a>              212 router/pns_node.h     int QueryColliding( const ITEM* aItem,</span>
<span class='curline'><a href='../S/678.html#L226'>ITEM</a>              226 router/pns_node.h                                   int                     aKindMask = ITEM::ANY_T,</span>
<span class='curline'><a href='../S/678.html#L227'>ITEM</a>              227 router/pns_node.h                                   const std::set&lt;ITEM*&gt;*  aRestrictedSet = NULL );</span>
<span class='curline'><a href='../S/678.html#L238'>ITEM</a>              238 router/pns_node.h     OPT_OBSTACLE CheckColliding( const ITEM*     aItem,</span>
<span class='curline'><a href='../S/678.html#L239'>ITEM</a>              239 router/pns_node.h                                  int             aKindMask = ITEM::ANY_T );</span>
<span class='curline'><a href='../S/678.html#L252'>ITEM</a>              252 router/pns_node.h                                  int              aKindMask = ITEM::ANY_T );</span>
<span class='curline'><a href='../S/678.html#L265'>ITEM</a>              265 router/pns_node.h     bool CheckColliding( const ITEM*    aItemA,</span>
<span class='curline'><a href='../S/678.html#L266'>ITEM</a>              266 router/pns_node.h                          const ITEM*    aItemB,</span>
<span class='curline'><a href='../S/678.html#L267'>ITEM</a>              267 router/pns_node.h                          int            aKindMask = ITEM::ANY_T,</span>
<span class='curline'><a href='../S/678.html#L296'>ITEM</a>              296 router/pns_node.h     void Add( std::unique_ptr&lt; ITEM &gt; aItem, bool aAllowRedundant = false );</span>
<span class='curline'><a href='../S/678.html#L308'>ITEM</a>              308 router/pns_node.h     void Remove( ITEM* aItem );</span>
<span class='curline'><a href='../S/678.html#L326'>ITEM</a>              326 router/pns_node.h     void Replace( ITEM* aOldItem, std::unique_ptr&lt; ITEM &gt; aNewItem );</span>
<span class='curline'><a href='../S/678.html#L381'>ITEM</a>              381 router/pns_node.h     void LockJoint( const VECTOR2I&amp; aPos, const ITEM* aItem, bool aLock );</span>
<span class='curline'><a href='../S/678.html#L389'>ITEM</a>              389 router/pns_node.h     JOINT* FindJoint( const VECTOR2I&amp; aPos, const ITEM* aItem )</span>
<span class='curline'><a href='../S/678.html#L397'>ITEM</a>              397 router/pns_node.h     ITEM* NearestUnconnectedItem( JOINT* aStart, int* aAnchor = NULL,</span>
<span class='curline'><a href='../S/678.html#L398'>ITEM</a>              398 router/pns_node.h                                       int aKindMask = ITEM::ANY_T);</span>
<span class='curline'><a href='../S/678.html#L413'>ITEM</a>              413 router/pns_node.h     void AllItemsInNet( int aNet, std::set&lt;ITEM*&gt;&amp; aItems );</span>
<span class='curline'><a href='../S/678.html#L420'>ITEM</a>              420 router/pns_node.h     ITEM* FindItemByParent( const BOARD_CONNECTED_ITEM* aParent );</span>
<span class='curline'><a href='../S/678.html#L434'>ITEM</a>              434 router/pns_node.h     bool Overrides( ITEM* aItem ) const</span>
<span class='curline'><a href='../S/678.html#L454'>ITEM</a>              454 router/pns_node.h     void linkJoint( const VECTOR2I&amp; aPos, const LAYER_RANGE&amp; aLayers, int aNet, ITEM* aWhere );</span>
<span class='curline'><a href='../S/678.html#L457'>ITEM</a>              457 router/pns_node.h     void unlinkJoint( const VECTOR2I&amp; aPos, const LAYER_RANGE&amp; aLayers, int aNet, ITEM* aWhere );</span>
<span class='curline'><a href='../S/678.html#L471'>ITEM</a>              471 router/pns_node.h     void doRemove( ITEM* aItem );</span>
<span class='curline'><a href='../S/678.html#L475'>ITEM</a>              475 router/pns_node.h     void rebuildJoint( JOINT* aJoint, ITEM* aItem );</span>
<span class='curline'><a href='../S/678.html#L508'>ITEM</a>              508 router/pns_node.h     std::unordered_set&lt;ITEM*&gt; m_override;</span>
<span class='curline'><a href='../S/678.html#L522'>ITEM</a>              522 router/pns_node.h     std::unordered_set&lt;ITEM*&gt; m_garbageItems;</span>
<span class='curline'><a href='../S/679.html#L135'>ITEM</a>              135 router/pns_optimizer.cpp     m_collisionKindMask( ITEM::ANY_T ),</span>
<span class='curline'><a href='../S/679.html#L150'>ITEM</a>              150 router/pns_optimizer.cpp     CACHE_VISITOR( const ITEM* aOurItem, NODE* aNode, int aMask ) :</span>
<span class='curline'><a href='../S/679.html#L157'>ITEM</a>              157 router/pns_optimizer.cpp     bool operator()( ITEM* aOtherItem )</span>
<span class='curline'><a href='../S/679.html#L171'>ITEM</a>              171 router/pns_optimizer.cpp     const ITEM* m_ourItem;</span>
<span class='curline'><a href='../S/679.html#L172'>ITEM</a>              172 router/pns_optimizer.cpp     ITEM* m_collidingItem;</span>
<span class='curline'><a href='../S/679.html#L178'>ITEM</a>              178 router/pns_optimizer.cpp void OPTIMIZER::cacheAdd( ITEM* aItem, bool aIsStatic = false )</span>
<span class='curline'><a href='../S/679.html#L207'>ITEM</a>              207 router/pns_optimizer.cpp void OPTIMIZER::CacheRemove( ITEM* aItem )</span>
<span class='curline'><a href='../S/679.html#L209'>ITEM</a>              209 router/pns_optimizer.cpp     if( aItem-&gt;Kind() == ITEM::LINE_T )</span>
<span class='curline'><a href='../S/679.html#L214'>ITEM</a>              214 router/pns_optimizer.cpp void OPTIMIZER::CacheStaticItem( ITEM* aItem )</span>
<span class='curline'><a href='../S/679.html#L400'>ITEM</a>              400 router/pns_optimizer.cpp     int cnt = m_world-&gt;QueryJoints( bb, joints, aOriginLine-&gt;Layers().Start(), ITEM::SOLID_T );</span>
<span class='curline'><a href='../S/679.html#L431'>ITEM</a>              431 router/pns_optimizer.cpp bool OPTIMIZER::checkColliding( ITEM* aItem, bool aUpdateCache )</span>
<span class='curline'><a href='../S/679.html#L707'>ITEM</a>              707 router/pns_optimizer.cpp         const ITEM* aItem, bool aPermitDiagonal ) const</span>
<span class='curline'><a href='../S/679.html#L804'>ITEM</a>              804 router/pns_optimizer.cpp         const ITEM* aItem, bool aPermitDiagonal ) const</span>
<span class='curline'><a href='../S/679.html#L808'>ITEM</a>              808 router/pns_optimizer.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/679.html#L814'>ITEM</a>              814 router/pns_optimizer.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/679.html#L851'>ITEM</a>              851 router/pns_optimizer.cpp ITEM* OPTIMIZER::findPadOrVia( int aLayer, int aNet, const VECTOR2I&amp; aP ) const</span>
<span class='curline'><a href='../S/679.html#L858'>ITEM</a>              858 router/pns_optimizer.cpp     for( ITEM* item : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/679.html#L860'>ITEM</a>              860 router/pns_optimizer.cpp         if( item-&gt;OfKind( ITEM::VIA_T | ITEM::SOLID_T ) )</span>
<span class='curline'><a href='../S/679.html#L868'>ITEM</a>              868 router/pns_optimizer.cpp int OPTIMIZER::smartPadsSingle( LINE* aLine, ITEM* aPad, bool aEnd, int aEndVertex )</span>
<span class='curline'><a href='../S/679.html#L991'>ITEM</a>              991 router/pns_optimizer.cpp     ITEM* startPad = findPadOrVia( aLine-&gt;Layer(), aLine-&gt;Net(), p_start );</span>
<span class='curline'><a href='../S/679.html#L992'>ITEM</a>              992 router/pns_optimizer.cpp     ITEM* endPad = findPadOrVia( aLine-&gt;Layer(), aLine-&gt;Net(), p_end );</span>
<span class='curline'><a href='../S/679.html#L1042'>ITEM</a>             1042 router/pns_optimizer.cpp     ITEM* startPad = findPadOrVia( aLine-&gt;Layer(), aLine-&gt;Net(), p_start );</span>
<span class='curline'><a href='../S/679.html#L1043'>ITEM</a>             1043 router/pns_optimizer.cpp     ITEM* endPad = findPadOrVia( aLine-&gt;Layer(), aLine-&gt;Net(), p_end );</span>
<span class='curline'><a href='../S/679.html#L1051'>ITEM</a>             1051 router/pns_optimizer.cpp     bool startMatch = startPad-&gt;OfKind( ITEM::VIA_T | ITEM::SOLID_T );</span>
<span class='curline'><a href='../S/679.html#L1056'>ITEM</a>             1056 router/pns_optimizer.cpp         endMatch = endPad-&gt;OfKind( ITEM::VIA_T | ITEM::SOLID_T );</span>
<span class='curline'><a href='../S/679.html#L1112'>ITEM</a>             1112 router/pns_optimizer.cpp     if( aNode-&gt;CheckColliding( &amp;refLine, &amp;coupledLine, ITEM::ANY_T, aPair-&gt;Gap() - 10 ) )</span>
<span class='curline'><a href='../S/680.html#L40'>ITEM</a>               40 router/pns_optimizer.h class ITEM;</span>
<span class='curline'><a href='../S/680.html#L119'>ITEM</a>              119 router/pns_optimizer.h     void CacheStaticItem( ITEM* aItem );</span>
<span class='curline'><a href='../S/680.html#L120'>ITEM</a>              120 router/pns_optimizer.h     void CacheRemove( ITEM* aItem );</span>
<span class='curline'><a href='../S/680.html#L168'>ITEM</a>              168 router/pns_optimizer.h     bool checkColliding( ITEM* aItem, bool aUpdateCache = true );</span>
<span class='curline'><a href='../S/680.html#L171'>ITEM</a>              171 router/pns_optimizer.h     void cacheAdd( ITEM* aItem, bool aIsStatic );</span>
<span class='curline'><a href='../S/680.html#L181'>ITEM</a>              181 router/pns_optimizer.h     BREAKOUT_LIST customBreakouts( int aWidth, const ITEM* aItem, bool aPermitDiagonal ) const;</span>
<span class='curline'><a href='../S/680.html#L182'>ITEM</a>              182 router/pns_optimizer.h     BREAKOUT_LIST computeBreakouts( int aWidth, const ITEM* aItem, bool aPermitDiagonal ) const;</span>
<span class='curline'><a href='../S/680.html#L184'>ITEM</a>              184 router/pns_optimizer.h     int smartPadsSingle( LINE* aLine, ITEM* aPad, bool aEnd, int aEndVertex );</span>
<span class='curline'><a href='../S/680.html#L186'>ITEM</a>              186 router/pns_optimizer.h     ITEM* findPadOrVia( int aLayer, int aNet, const VECTOR2I&amp; aP ) const;</span>
<span class='curline'><a href='../S/680.html#L188'>ITEM</a>              188 router/pns_optimizer.h     SHAPE_INDEX_LIST&lt;ITEM*&gt; m_cache;</span>
<span class='curline'><a href='../S/681.html#L34'>ITEM</a>               34 router/pns_placement_algo.h class ITEM;</span>
<span class='curline'><a href='../S/681.html#L59'>ITEM</a>               59 router/pns_placement_algo.h     virtual bool Start( const VECTOR2I&amp; aP, ITEM* aStartItem ) = 0;</span>
<span class='curline'><a href='../S/681.html#L68'>ITEM</a>               68 router/pns_placement_algo.h     virtual bool Move( const VECTOR2I&amp; aP, ITEM* aEndItem ) = 0;</span>
<span class='curline'><a href='../S/681.html#L79'>ITEM</a>               79 router/pns_placement_algo.h     virtual bool FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish = false ) = 0;</span>
<span class='curline'><a href='../S/682.html#L134'>ITEM</a>              134 router/pns_router.cpp bool ROUTER::StartDragging( const VECTOR2I&amp; aP, ITEM* aItem, int aDragMode )</span>
<span class='curline'><a href='../S/682.html#L145'>ITEM</a>              145 router/pns_router.cpp     if( aStartItems.Count( ITEM::SOLID_T ) == aStartItems.Size() )</span>
<span class='curline'><a href='../S/682.html#L184'>ITEM</a>              184 router/pns_router.cpp     for( ITEM* item : candidates.Items() )</span>
<span class='curline'><a href='../S/682.html#L195'>ITEM</a>              195 router/pns_router.cpp bool ROUTER::StartRouting( const VECTOR2I&amp; aP, ITEM* aStartItem, int aLayer )</span>
<span class='curline'><a href='../S/682.html#L252'>ITEM</a>              252 router/pns_router.cpp     for( const ITEM* item : aItems.CItems() )</span>
<span class='curline'><a href='../S/682.html#L257'>ITEM</a>              257 router/pns_router.cpp void ROUTER::Move( const VECTOR2I&amp; aP, ITEM* endItem )</span>
<span class='curline'><a href='../S/682.html#L282'>ITEM</a>              282 router/pns_router.cpp void ROUTER::moveDragging( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/682.html#L295'>ITEM</a>              295 router/pns_router.cpp     for( ITEM* item : aCurrent.Items() )</span>
<span class='curline'><a href='../S/682.html#L299'>ITEM</a>              299 router/pns_router.cpp         aNode-&gt;QueryColliding( item, obstacles, ITEM::ANY_T );</span>
<span class='curline'><a href='../S/682.html#L301'>ITEM</a>              301 router/pns_router.cpp         if( item-&gt;OfKind( ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/682.html#L308'>ITEM</a>              308 router/pns_router.cpp                 aNode-&gt;QueryColliding( &amp;v, obstacles, ITEM::ANY_T );</span>
<span class='curline'><a href='../S/682.html#L315'>ITEM</a>              315 router/pns_router.cpp             std::unique_ptr&lt;ITEM&gt; tmp( obs.m_item-&gt;Clone() );</span>
<span class='curline'><a href='../S/682.html#L360'>ITEM</a>              360 router/pns_router.cpp void ROUTER::movePlacing( const VECTOR2I&amp; aP, ITEM* aEndItem )</span>
<span class='curline'><a href='../S/682.html#L367'>ITEM</a>              367 router/pns_router.cpp     for( const ITEM* item : current.CItems() )</span>
<span class='curline'><a href='../S/682.html#L369'>ITEM</a>              369 router/pns_router.cpp         if( !item-&gt;OfKind( ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/682.html#L407'>ITEM</a>              407 router/pns_router.cpp bool ROUTER::FixRoute( const VECTOR2I&amp; aP, ITEM* aEndItem, bool aForceFinish )</span>
<span class='curline'><a href='../S/682.html#L570'>ITEM</a>              570 router/pns_router.cpp void ROUTER::BreakSegment( ITEM *aItem, const VECTOR2I&amp; aP )</span>
<span class='curline'><a href='../S/683.html#L55'>ITEM</a>               55 router/pns_router.h class ITEM;</span>
<span class='curline'><a href='../S/683.html#L99'>ITEM</a>               99 router/pns_router.h         virtual void AddItem( ITEM* aItem ) = 0;</span>
<span class='curline'><a href='../S/683.html#L100'>ITEM</a>              100 router/pns_router.h         virtual void RemoveItem( ITEM* aItem ) = 0;</span>
<span class='curline'><a href='../S/683.html#L102'>ITEM</a>              102 router/pns_router.h         virtual bool IsItemVisible( const PNS::ITEM* aItem ) = 0;</span>
<span class='curline'><a href='../S/683.html#L103'>ITEM</a>              103 router/pns_router.h         virtual void DisplayItem( const ITEM* aItem, int aColor = -1, int aClearance = -1, bool aEdit = false ) = 0;</span>
<span class='curline'><a href='../S/683.html#L104'>ITEM</a>              104 router/pns_router.h         virtual void HideItem( ITEM* aItem ) = 0;</span>
<span class='curline'><a href='../S/683.html#L143'>ITEM</a>              143 router/pns_router.h     bool StartRouting( const VECTOR2I&amp; aP, ITEM* aItem, int aLayer );</span>
<span class='curline'><a href='../S/683.html#L144'>ITEM</a>              144 router/pns_router.h     void Move( const VECTOR2I&amp; aP, ITEM* aItem );</span>
<span class='curline'><a href='../S/683.html#L145'>ITEM</a>              145 router/pns_router.h     bool FixRoute( const VECTOR2I&amp; aP, ITEM* aItem, bool aForceFinish = false );</span>
<span class='curline'><a href='../S/683.html#L146'>ITEM</a>              146 router/pns_router.h     void BreakSegment( ITEM *aItem, const VECTOR2I&amp; aP );</span>
<span class='curline'><a href='../S/683.html#L152'>ITEM</a>              152 router/pns_router.h     int GetClearance( const ITEM* aA, const ITEM* aB ) const;</span>
<span class='curline'><a href='../S/683.html#L161'>ITEM</a>              161 router/pns_router.h     void DisplayItem( const ITEM* aItem, int aColor = -1, int aClearance = -1, bool aEdit = false );</span>
<span class='curline'><a href='../S/683.html#L163'>ITEM</a>              163 router/pns_router.h     void DeleteTraces( ITEM* aStartItem, bool aWholeTrack );</span>
<span class='curline'><a href='../S/683.html#L185'>ITEM</a>              185 router/pns_router.h     const VECTOR2I      SnapToItem( ITEM* aItem, VECTOR2I aP, bool&amp; aSplitsSegment );</span>
<span class='curline'><a href='../S/683.html#L187'>ITEM</a>              187 router/pns_router.h     bool StartDragging( const VECTOR2I&amp; aP, ITEM* aItem, int aDragMode = DM_ANY );</span>
<span class='curline'><a href='../S/683.html#L226'>ITEM</a>              226 router/pns_router.h     ITEM* QueryItemByParent( const BOARD_ITEM* aItem ) const;</span>
<span class='curline'><a href='../S/683.html#L239'>ITEM</a>              239 router/pns_router.h     void movePlacing( const VECTOR2I&amp; aP, ITEM* aItem );</span>
<span class='curline'><a href='../S/683.html#L240'>ITEM</a>              240 router/pns_router.h     void moveDragging( const VECTOR2I&amp; aP, ITEM* aItem );</span>
<span class='curline'><a href='../S/683.html#L249'>ITEM</a>              249 router/pns_router.h     ITEM* pickSingleItem( ITEM_SET&amp; aItems ) const;</span>
<span class='curline'><a href='../S/683.html#L250'>ITEM</a>              250 router/pns_router.h     void splitAdjacentSegments( NODE* aNode, ITEM* aSeg, const VECTOR2I&amp; aP );</span>
<span class='curline'><a href='../S/683.html#L252'>ITEM</a>              252 router/pns_router.h     ITEM* syncPad( D_PAD* aPad );</span>
<span class='curline'><a href='../S/683.html#L253'>ITEM</a>              253 router/pns_router.h     ITEM* syncTrack( TRACK* aTrack );</span>
<span class='curline'><a href='../S/683.html#L254'>ITEM</a>              254 router/pns_router.h     ITEM* syncVia( VIA* aVia );</span>
<span class='curline'><a href='../S/686.html#L61'>ITEM</a>               61 router/pns_segment.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/687.html#L47'>ITEM</a>               47 router/pns_shove.cpp void SHOVE::replaceItems( ITEM* aOld, std::unique_ptr&lt; ITEM &gt; aNew )</span>
<span class='curline'><a href='../S/687.html#L67'>ITEM</a>               67 router/pns_shove.cpp int SHOVE::getClearance( const ITEM* aA, const ITEM* aB ) const</span>
<span class='curline'><a href='../S/687.html#L237'>ITEM</a>              237 router/pns_shove.cpp         bool colliding = m_currentNode-&gt;CheckColliding( &amp;l, &amp;aCurrent, ITEM::ANY_T, m_forceClearance );</span>
<span class='curline'><a href='../S/687.html#L249'>ITEM</a>              249 router/pns_shove.cpp             for( ITEM* item : jtStart-&gt;LinkList() )</span>
<span class='curline'><a href='../S/687.html#L507'>ITEM</a>              507 router/pns_shove.cpp SHOVE::SHOVE_STATUS SHOVE::onCollidingSolid( LINE&amp; aCurrent, ITEM* aObstacle )</span>
<span class='curline'><a href='../S/687.html#L521'>ITEM</a>              521 router/pns_shove.cpp         for( ITEM* item : jtStart-&gt;LinkList() )</span>
<span class='curline'><a href='../S/687.html#L523'>ITEM</a>              523 router/pns_shove.cpp             if( item-&gt;OfKind( ITEM::VIA_T ) )</span>
<span class='curline'><a href='../S/687.html#L536'>ITEM</a>              536 router/pns_shove.cpp     std::set&lt;ITEM*&gt; cluster = topo.AssembleCluster( aObstacle, aCurrent.Layers().Start() );</span>
<span class='curline'><a href='../S/687.html#L540'>ITEM</a>              540 router/pns_shove.cpp     for( ITEM* item : cluster )</span>
<span class='curline'><a href='../S/687.html#L743'>ITEM</a>              743 router/pns_shove.cpp     for( ITEM* item : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/687.html#L745'>ITEM</a>              745 router/pns_shove.cpp         if( item-&gt;OfKind( ITEM::SEGMENT_T | ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/687.html#L832'>ITEM</a>              832 router/pns_shove.cpp SHOVE::SHOVE_STATUS SHOVE::onCollidingVia( ITEM* aCurrent, VIA* aObstacleVia )</span>
<span class='curline'><a href='../S/687.html#L847'>ITEM</a>              847 router/pns_shove.cpp     if( aCurrent-&gt;OfKind( ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/687.html#L893'>ITEM</a>              893 router/pns_shove.cpp     else if( aCurrent-&gt;OfKind( ITEM::SOLID_T ) )</span>
<span class='curline'><a href='../S/687.html#L920'>ITEM</a>              920 router/pns_shove.cpp     for( ITEM* item : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/687.html#L922'>ITEM</a>              922 router/pns_shove.cpp         if( item-&gt;OfKind( ITEM::SEGMENT_T | ITEM::ARC_T ) &amp;&amp; item-&gt;LayersOverlap( &amp;aCurrent ) )</span>
<span class='curline'><a href='../S/687.html#L1010'>ITEM</a>             1010 router/pns_shove.cpp void SHOVE::unwindLineStack( ITEM* aItem )</span>
<span class='curline'><a href='../S/687.html#L1012'>ITEM</a>             1012 router/pns_shove.cpp     if( aItem-&gt;OfKind( ITEM::SEGMENT_T  | ITEM::ARC_T ) )</span>
<span class='curline'><a href='../S/687.html#L1014'>ITEM</a>             1014 router/pns_shove.cpp     else if( aItem-&gt;OfKind( ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/687.html#L1082'>ITEM</a>             1082 router/pns_shove.cpp     for( ITEM::PnsKind search_order : { ITEM::SOLID_T, ITEM::VIA_T, ITEM::SEGMENT_T } )</span>
<span class='curline'><a href='../S/687.html#L1096'>ITEM</a>             1096 router/pns_shove.cpp     ITEM* ni = nearest-&gt;m_item;</span>
<span class='curline'><a href='../S/687.html#L1100'>ITEM</a>             1100 router/pns_shove.cpp     if( !ni-&gt;OfKind( ITEM::SOLID_T ) &amp;&amp; ni-&gt;Rank() &gt;= 0 &amp;&amp; ni-&gt;Rank() &gt; currentLine.Rank() )</span>
<span class='curline'><a href='../S/687.html#L1106'>ITEM</a>             1106 router/pns_shove.cpp         case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/687.html#L1123'>ITEM</a>             1123 router/pns_shove.cpp         case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/687.html#L1136'>ITEM</a>             1136 router/pns_shove.cpp         case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/687.html#L1160'>ITEM</a>             1160 router/pns_shove.cpp         case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/687.html#L1171'>ITEM</a>             1171 router/pns_shove.cpp         case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/687.html#L1181'>ITEM</a>             1181 router/pns_shove.cpp         case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/687.html#L1190'>ITEM</a>             1190 router/pns_shove.cpp         case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/687.html#L1382'>ITEM</a>             1382 router/pns_shove.cpp     for( const ITEM* item : aHeadSet.CItems() )</span>
<span class='curline'><a href='../S/687.html#L1407'>ITEM</a>             1407 router/pns_shove.cpp     for( const ITEM* item : aHeadSet.CItems() )</span>
<span class='curline'><a href='../S/687.html#L1461'>ITEM</a>             1461 router/pns_shove.cpp     for( ITEM* item : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/687.html#L1463'>ITEM</a>             1463 router/pns_shove.cpp         if ( item-&gt;OfKind( ITEM::VIA_T ))</span>
<span class='curline'><a href='../S/687.html#L1592'>ITEM</a>             1592 router/pns_shove.cpp     optimizer.SetCollisionMask( ITEM::ANY_T );</span>
<span class='curline'><a href='../S/688.html#L130'>ITEM</a>              130 router/pns_shove.h     SHOVE_STATUS onCollidingSolid( LINE&amp; aCurrent, ITEM* aObstacle );</span>
<span class='curline'><a href='../S/688.html#L131'>ITEM</a>              131 router/pns_shove.h     SHOVE_STATUS onCollidingVia( ITEM* aCurrent, VIA* aObstacleVia );</span>
<span class='curline'><a href='../S/688.html#L138'>ITEM</a>              138 router/pns_shove.h     void unwindLineStack( ITEM* aItem );</span>
<span class='curline'><a href='../S/688.html#L147'>ITEM</a>              147 router/pns_shove.h     void replaceItems( ITEM* aOld, std::unique_ptr&lt; ITEM &gt; aNew );</span>
<span class='curline'><a href='../S/688.html#L155'>ITEM</a>              155 router/pns_shove.h     int getClearance( const ITEM* aA, const ITEM* aB ) const;</span>
<span class='curline'><a href='../S/689.html#L32'>ITEM</a>               32 router/pns_sizes_settings.cpp int SIZES_SETTINGS::inheritTrackWidth( ITEM* aItem )</span>
<span class='curline'><a href='../S/689.html#L40'>ITEM</a>               40 router/pns_sizes_settings.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/689.html#L44'>ITEM</a>               44 router/pns_sizes_settings.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/689.html#L48'>ITEM</a>               48 router/pns_sizes_settings.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/689.html#L63'>ITEM</a>               63 router/pns_sizes_settings.cpp     linkedSegs.ExcludeItem( aItem ).FilterKinds( ITEM::SEGMENT_T );</span>
<span class='curline'><a href='../S/689.html#L65'>ITEM</a>               65 router/pns_sizes_settings.cpp     for( ITEM* item : linkedSegs.Items() )</span>
<span class='curline'><a href='../S/689.html#L75'>ITEM</a>               75 router/pns_sizes_settings.cpp void SIZES_SETTINGS::Init( BOARD* aBoard, ITEM* aStartItem, int aNet )</span>
<span class='curline'><a href='../S/690.html#L35'>ITEM</a>               35 router/pns_sizes_settings.h class ITEM;</span>
<span class='curline'><a href='../S/690.html#L52'>ITEM</a>               52 router/pns_sizes_settings.h     void Init( BOARD* aBoard, ITEM* aStartItem = NULL, int aNet = -1 );</span>
<span class='curline'><a href='../S/690.html#L107'>ITEM</a>              107 router/pns_sizes_settings.h     int inheritTrackWidth( ITEM* aItem );</span>
<span class='curline'><a href='../S/691.html#L76'>ITEM</a>               76 router/pns_solid.cpp ITEM* SOLID::Clone() const</span>
<span class='curline'><a href='../S/691.html#L78'>ITEM</a>               78 router/pns_solid.cpp     ITEM* solid = new SOLID( *this );</span>
<span class='curline'><a href='../S/692.html#L35'>ITEM</a>               35 router/pns_solid.h class SOLID : public ITEM</span>
<span class='curline'><a href='../S/692.html#L38'>ITEM</a>               38 router/pns_solid.h     SOLID() : ITEM( SOLID_T ), m_shape( NULL )</span>
<span class='curline'><a href='../S/692.html#L50'>ITEM</a>               50 router/pns_solid.h         ITEM( aSolid )</span>
<span class='curline'><a href='../S/692.html#L57'>ITEM</a>               57 router/pns_solid.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/692.html#L62'>ITEM</a>               62 router/pns_solid.h     ITEM* Clone() const override;</span>
<span class='curline'><a href='../S/693.html#L122'>ITEM</a>              122 router/pns_tool_base.cpp ITEM* TOOL_BASE::pickSingleItem( const VECTOR2I&amp; aWhere, int aNet, int aLayer, bool aIgnorePads,</span>
<span class='curline'><a href='../S/693.html#L123'>ITEM</a>              123 router/pns_tool_base.cpp 								 const std::vector&lt;ITEM*&gt; aAvoidItems )</span>
<span class='curline'><a href='../S/693.html#L131'>ITEM</a>              131 router/pns_tool_base.cpp     ITEM* prioritized[candidateCount];</span>
<span class='curline'><a href='../S/693.html#L142'>ITEM</a>              142 router/pns_tool_base.cpp     for( ITEM* item : candidates.Items() )</span>
<span class='curline'><a href='../S/693.html#L162'>ITEM</a>              162 router/pns_tool_base.cpp             if( item-&gt;OfKind( ITEM::VIA_T | ITEM::SOLID_T ) )</span>
<span class='curline'><a href='../S/693.html#L164'>ITEM</a>              164 router/pns_tool_base.cpp                 if( item-&gt;OfKind( ITEM::SOLID_T ) &amp;&amp; aIgnorePads )</span>
<span class='curline'><a href='../S/693.html#L191'>ITEM</a>              191 router/pns_tool_base.cpp             if( item-&gt;OfKind( ITEM::SOLID_T ) &amp;&amp; aIgnorePads )</span>
<span class='curline'><a href='../S/693.html#L199'>ITEM</a>              199 router/pns_tool_base.cpp     ITEM* rv = NULL;</span>
<span class='curline'><a href='../S/693.html#L206'>ITEM</a>              206 router/pns_tool_base.cpp         ITEM* item = prioritized[i];</span>
<span class='curline'><a href='../S/693.html#L251'>ITEM</a>              251 router/pns_tool_base.cpp bool TOOL_BASE::checkSnap( ITEM *aItem )</span>
<span class='curline'><a href='../S/693.html#L266'>ITEM</a>              266 router/pns_tool_base.cpp         if( aItem-&gt;OfKind( ITEM::VIA_T | ITEM::SEGMENT_T | ITEM::ARC_T )  )</span>
<span class='curline'><a href='../S/693.html#L268'>ITEM</a>              268 router/pns_tool_base.cpp         else if( aItem-&gt;OfKind( ITEM::SOLID_T ) )</span>
<span class='curline'><a href='../S/693.html#L336'>ITEM</a>              336 router/pns_tool_base.cpp     ITEM* endItem = nullptr;</span>
<span class='curline'><a href='../S/693.html#L366'>ITEM</a>              366 router/pns_tool_base.cpp void TOOL_BASE::deleteTraces( ITEM* aStartItem, bool aWholeTrack )</span>
<span class='curline'><a href='../S/693.html#L396'>ITEM</a>              396 router/pns_tool_base.cpp const VECTOR2I TOOL_BASE::snapToItem( bool aEnabled, ITEM* aItem, VECTOR2I aP)</span>
<span class='curline'><a href='../S/693.html#L407'>ITEM</a>              407 router/pns_tool_base.cpp     case ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/693.html#L411'>ITEM</a>              411 router/pns_tool_base.cpp     case ITEM::VIA_T:</span>
<span class='curline'><a href='../S/693.html#L415'>ITEM</a>              415 router/pns_tool_base.cpp     case ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/693.html#L416'>ITEM</a>              416 router/pns_tool_base.cpp     case ITEM::ARC_T:</span>
<span class='curline'><a href='../S/693.html#L428'>ITEM</a>              428 router/pns_tool_base.cpp             if( aItem-&gt;Kind() == ITEM::SEGMENT_T )</span>
<span class='curline'><a href='../S/693.html#L430'>ITEM</a>              430 router/pns_tool_base.cpp             else if( aItem-&gt;Kind() == ITEM::ARC_T )</span>
<span class='curline'><a href='../S/694.html#L55'>ITEM</a>               55 router/pns_tool_base.h     bool checkSnap( ITEM* aItem );</span>
<span class='curline'><a href='../S/694.html#L56'>ITEM</a>               56 router/pns_tool_base.h     const VECTOR2I snapToItem( bool aEnabled, ITEM* aItem, VECTOR2I aP);</span>
<span class='curline'><a href='../S/694.html#L57'>ITEM</a>               57 router/pns_tool_base.h     virtual ITEM* pickSingleItem( const VECTOR2I&amp; aWhere, int aNet = -1, int aLayer = -1,</span>
<span class='curline'><a href='../S/694.html#L58'>ITEM</a>               58 router/pns_tool_base.h                                   bool aIgnorePads = false, const std::vector&lt;ITEM*&gt; aAvoidItems = {} );</span>
<span class='curline'><a href='../S/694.html#L62'>ITEM</a>               62 router/pns_tool_base.h     void deleteTraces( ITEM* aStartItem, bool aWholeTrack );</span>
<span class='curline'><a href='../S/694.html#L67'>ITEM</a>               67 router/pns_tool_base.h     ITEM* m_startItem;</span>
<span class='curline'><a href='../S/694.html#L72'>ITEM</a>               72 router/pns_tool_base.h     ITEM* m_endItem;</span>
<span class='curline'><a href='../S/695.html#L74'>ITEM</a>               74 router/pns_topology.cpp         for( ITEM* item : current-&gt;LinkList() )</span>
<span class='curline'><a href='../S/695.html#L76'>ITEM</a>               76 router/pns_topology.cpp             if( item-&gt;OfKind( ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/695.html#L121'>ITEM</a>              121 router/pns_topology.cpp         ITEM* it = topo.NearestUnconnectedItem( jt, &amp;anchor );</span>
<span class='curline'><a href='../S/695.html#L136'>ITEM</a>              136 router/pns_topology.cpp ITEM* TOPOLOGY::NearestUnconnectedItem( JOINT* aStart, int* aAnchor, int aKindMask )</span>
<span class='curline'><a href='../S/695.html#L138'>ITEM</a>              138 router/pns_topology.cpp     std::set&lt;ITEM*&gt; disconnected;</span>
<span class='curline'><a href='../S/695.html#L144'>ITEM</a>              144 router/pns_topology.cpp         for( ITEM* link : jt-&gt;LinkList() )</span>
<span class='curline'><a href='../S/695.html#L152'>ITEM</a>              152 router/pns_topology.cpp     ITEM* best = NULL;</span>
<span class='curline'><a href='../S/695.html#L154'>ITEM</a>              154 router/pns_topology.cpp     for( ITEM* item : disconnected )</span>
<span class='curline'><a href='../S/695.html#L179'>ITEM</a>              179 router/pns_topology.cpp bool TOPOLOGY::followTrivialPath( LINE* aLine, bool aLeft, ITEM_SET&amp; aSet, std::set&lt;ITEM*&gt;&amp; aVisited )</span>
<span class='curline'><a href='../S/695.html#L194'>ITEM</a>              194 router/pns_topology.cpp         ITEM* via = NULL;</span>
<span class='curline'><a href='../S/695.html#L197'>ITEM</a>              197 router/pns_topology.cpp         for( ITEM* link : jt-&gt;Links().Items() )</span>
<span class='curline'><a href='../S/695.html#L199'>ITEM</a>              199 router/pns_topology.cpp             if( link-&gt;OfKind( ITEM::VIA_T ) )</span>
<span class='curline'><a href='../S/695.html#L239'>ITEM</a>              239 router/pns_topology.cpp const ITEM_SET TOPOLOGY::AssembleTrivialPath( ITEM* aStart )</span>
<span class='curline'><a href='../S/695.html#L242'>ITEM</a>              242 router/pns_topology.cpp     std::set&lt;ITEM*&gt; visited;</span>
<span class='curline'><a href='../S/695.html#L280'>ITEM</a>              280 router/pns_topology.cpp const ITEM_SET TOPOLOGY::ConnectedItems( ITEM* aStart, int aKindMask )</span>
<span class='curline'><a href='../S/695.html#L289'>ITEM</a>              289 router/pns_topology.cpp bool TOPOLOGY::AssembleDiffPair( ITEM* aStart, DIFF_PAIR&amp; aPair )</span>
<span class='curline'><a href='../S/695.html#L297'>ITEM</a>              297 router/pns_topology.cpp     std::set&lt;ITEM*&gt; coupledItems;</span>
<span class='curline'><a href='../S/695.html#L306'>ITEM</a>              306 router/pns_topology.cpp         for( ITEM* item : coupledItems )</span>
<span class='curline'><a href='../S/695.html#L361'>ITEM</a>              361 router/pns_topology.cpp const std::set&lt;ITEM*&gt; TOPOLOGY::AssembleCluster( ITEM* aStart, int aLayer )</span>
<span class='curline'><a href='../S/695.html#L363'>ITEM</a>              363 router/pns_topology.cpp     std::set&lt;ITEM*&gt; visited;</span>
<span class='curline'><a href='../S/695.html#L364'>ITEM</a>              364 router/pns_topology.cpp     std::deque&lt;ITEM*&gt; pending;</span>
<span class='curline'><a href='../S/695.html#L371'>ITEM</a>              371 router/pns_topology.cpp         ITEM* top = pending.front();</span>
<span class='curline'><a href='../S/695.html#L377'>ITEM</a>              377 router/pns_topology.cpp         m_world-&gt;QueryColliding( top, obstacles, ITEM::ANY_T, -1, false );</span>
<span class='curline'><a href='../S/696.html#L35'>ITEM</a>               35 router/pns_topology.h class ITEM;</span>
<span class='curline'><a href='../S/696.html#L50'>ITEM</a>               50 router/pns_topology.h     ITEM* NearestUnconnectedItem( JOINT* aStart, int* aAnchor = NULL, int aKindMask = ITEM::ANY_T );</span>
<span class='curline'><a href='../S/696.html#L54'>ITEM</a>               54 router/pns_topology.h     const ITEM_SET ConnectedItems( JOINT* aStart, int aKindMask = ITEM::ANY_T );</span>
<span class='curline'><a href='../S/696.html#L55'>ITEM</a>               55 router/pns_topology.h     const ITEM_SET ConnectedItems( ITEM* aStart, int aKindMask = ITEM::ANY_T );</span>
<span class='curline'><a href='../S/696.html#L56'>ITEM</a>               56 router/pns_topology.h     int64_t ShortestConnectionLength( ITEM* aFrom, ITEM* aTo );</span>
<span class='curline'><a href='../S/696.html#L58'>ITEM</a>               58 router/pns_topology.h     const ITEM_SET AssembleTrivialPath( ITEM* aStart );</span>
<span class='curline'><a href='../S/696.html#L64'>ITEM</a>               64 router/pns_topology.h     bool AssembleDiffPair( ITEM* aStart, DIFF_PAIR&amp; aPair );</span>
<span class='curline'><a href='../S/696.html#L66'>ITEM</a>               66 router/pns_topology.h     const std::set&lt;ITEM*&gt; AssembleCluster( ITEM* aStart, int aLayer );</span>
<span class='curline'><a href='../S/696.html#L69'>ITEM</a>               69 router/pns_topology.h     bool followTrivialPath( LINE* aLine, bool aLeft, ITEM_SET&amp; aSet, std::set&lt;ITEM*&gt;&amp; aVisited );</span>
<span class='curline'><a href='../S/699.html#L290'>ITEM</a>              290 router/pns_utils.cpp OPT_BOX2I ChangedArea( const ITEM* aItemA, const ITEM* aItemB )</span>
<span class='curline'><a href='../S/699.html#L292'>ITEM</a>              292 router/pns_utils.cpp     if( aItemA-&gt;OfKind( ITEM::VIA_T ) &amp;&amp; aItemB-&gt;OfKind( ITEM::VIA_T ) )</span>
<span class='curline'><a href='../S/699.html#L299'>ITEM</a>              299 router/pns_utils.cpp     else if( aItemA-&gt;OfKind( ITEM::LINE_T ) &amp;&amp; aItemB-&gt;OfKind( ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/700.html#L36'>ITEM</a>               36 router/pns_utils.h class ITEM;</span>
<span class='curline'><a href='../S/700.html#L61'>ITEM</a>               61 router/pns_utils.h OPT_BOX2I ChangedArea( const ITEM* aItemA, const ITEM* aItemB );</span>
<span class='curline'><a href='../S/701.html#L41'>ITEM</a>               41 router/pns_via.cpp         NODE::OPT_OBSTACLE obs = aNode-&gt;CheckColliding( &amp;mv, aSolidsOnly ? ITEM::SOLID_T</span>
<span class='curline'><a href='../S/701.html#L42'>ITEM</a>               42 router/pns_via.cpp                                                                          : ITEM::ANY_T );</span>
<span class='curline'><a href='../S/702.html#L48'>ITEM</a>               48 router/pns_via.h class VIA : public ITEM</span>
<span class='curline'><a href='../S/702.html#L52'>ITEM</a>               52 router/pns_via.h         ITEM( VIA_T )</span>
<span class='curline'><a href='../S/702.html#L61'>ITEM</a>               61 router/pns_via.h             : ITEM( VIA_T )</span>
<span class='curline'><a href='../S/702.html#L81'>ITEM</a>               81 router/pns_via.h         ITEM( aB )</span>
<span class='curline'><a href='../S/702.html#L94'>ITEM</a>               94 router/pns_via.h     static inline bool ClassOf( const ITEM* aItem )</span>
<span class='curline'><a href='../S/704.html#L49'>ITEM</a>               49 router/pns_walkaround.h         m_itemMask = ITEM::ANY_T;</span>
<span class='curline'><a href='../S/704.html#L96'>ITEM</a>               96 router/pns_walkaround.h             m_itemMask = ITEM::SOLID_T;</span>
<span class='curline'><a href='../S/704.html#L98'>ITEM</a>               98 router/pns_walkaround.h             m_itemMask = ITEM::ANY_T;</span>
<span class='curline'><a href='../S/704.html#L129'>ITEM</a>              129 router/pns_walkaround.h     void RestrictToSet( bool aEnabled, const std::set&lt;ITEM*&gt;&amp; aSet )</span>
<span class='curline'><a href='../S/704.html#L162'>ITEM</a>              162 router/pns_walkaround.h     std::set&lt;ITEM*&gt; m_restrictedSet;</span>
<span class='curline'><a href='../S/707.html#L40'>ITEM</a>               40 router/router_preview_item.cpp ROUTER_PREVIEW_ITEM::ROUTER_PREVIEW_ITEM( const PNS::ITEM* aItem, KIGFX::VIEW* aView ) :</span>
<span class='curline'><a href='../S/707.html#L70'>ITEM</a>               70 router/router_preview_item.cpp void ROUTER_PREVIEW_ITEM::Update( const PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/707.html#L74'>ITEM</a>               74 router/router_preview_item.cpp     if( aItem-&gt;OfKind( PNS::ITEM::LINE_T ) )</span>
<span class='curline'><a href='../S/707.html#L92'>ITEM</a>               92 router/router_preview_item.cpp     case PNS::ITEM::LINE_T:</span>
<span class='curline'><a href='../S/707.html#L97'>ITEM</a>               97 router/router_preview_item.cpp     case PNS::ITEM::ARC_T:</span>
<span class='curline'><a href='../S/707.html#L102'>ITEM</a>              102 router/router_preview_item.cpp     case PNS::ITEM::SEGMENT_T:</span>
<span class='curline'><a href='../S/707.html#L107'>ITEM</a>              107 router/router_preview_item.cpp     case PNS::ITEM::VIA_T:</span>
<span class='curline'><a href='../S/707.html#L115'>ITEM</a>              115 router/router_preview_item.cpp     case PNS::ITEM::SOLID_T:</span>
<span class='curline'><a href='../S/708.html#L44'>ITEM</a>               44 router/router_preview_item.h class ITEM;</span>
<span class='curline'><a href='../S/708.html#L59'>ITEM</a>               59 router/router_preview_item.h     ROUTER_PREVIEW_ITEM( const PNS::ITEM* aItem = NULL, KIGFX::VIEW* aView = NULL);</span>
<span class='curline'><a href='../S/708.html#L62'>ITEM</a>               62 router/router_preview_item.h     void Update( const PNS::ITEM* aItem );</span>
<span class='curline'><a href='../S/709.html#L517'>ITEM</a>              517 router/router_tool.cpp int ROUTER_TOOL::getStartLayer( const PNS::ITEM* aItem )</span>
<span class='curline'><a href='../S/709.html#L1084'>ITEM</a>             1084 router/router_tool.cpp     if( m_startItem &amp;&amp; m_startItem-&gt;OfKind( PNS::ITEM::SEGMENT_T ) )</span>
<span class='curline'><a href='../S/709.html#L1380'>ITEM</a>             1380 router/router_tool.cpp     PNS::ITEM* startItem = nullptr;</span>
<span class='curline'><a href='../S/710.html#L64'>ITEM</a>               64 router/router_tool.h     int getStartLayer( const PNS::ITEM* aItem );</span>
</pre>
</body>
</html>
